diff -Nru cyrus-sasl-2.1.22.orig/cmake/modules/FindWcecompat.cmake cyrus-sasl-2.1.22/cmake/modules/FindWcecompat.cmake
--- cyrus-sasl-2.1.22.orig/cmake/modules/FindWcecompat.cmake	1970-01-01 01:00:00.000000000 +0100
+++ cyrus-sasl-2.1.22/cmake/modules/FindWcecompat.cmake	2010-10-06 18:51:42.109171900 +0200
@@ -0,0 +1,33 @@
+# Try to find Wcecompat functionality
+# Once done this will define
+#
+#  WCECOMPAT_FOUND - system has Wcecompat
+#  WCECOMPAT_INCLUDE_DIR - Wcecompat include directory
+#  WCECOMPAT_LIBRARIES - Libraries needed to use Wcecompat
+#
+# Copyright (c) 2010, Andreas Holzammer, <andy@kdab.com>
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+
+if(WCECOMPAT_INCLUDE_DIR AND WCECOMPAT_LIB_FOUND)
+  set(Wcecompat_FIND_QUIETLY TRUE)
+endif(WCECOMPAT_INCLUDE_DIR AND WCECOMPAT_LIB_FOUND)
+
+find_path(WCECOMPAT_INCLUDE_DIR errno.h PATH_SUFFIXES wcecompat)
+
+set(WCECOMPAT_LIB_FOUND FALSE)
+
+if(WCECOMPAT_INCLUDE_DIR)
+    find_library(WCECOMPAT_LIBRARIES NAMES wcecompat wcecompatex )
+    if(WCECOMPAT_LIBRARIES)
+      set(WCECOMPAT_LIB_FOUND TRUE)
+    endif(WCECOMPAT_LIBRARIES)
+endif(WCECOMPAT_INCLUDE_DIR)
+
+# I have no idea what this is about, but it seems to be used quite often, so I add this here
+set(WCECOMPAT_CONST const)
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(Wcecompat  DEFAULT_MSG  WCECOMPAT_LIBRARIES  WCECOMPAT_LIB_FOUND)
+
+mark_as_advanced(WCECOMPAT_INCLUDE_DIR  WCECOMPAT_LIBRARIES  WCECOMPAT_CONST  WCECOMPAT_LIB_FOUND)
diff -Nru cyrus-sasl-2.1.22.orig/CMakeLists.txt cyrus-sasl-2.1.22/CMakeLists.txt
--- cyrus-sasl-2.1.22.orig/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ cyrus-sasl-2.1.22/CMakeLists.txt	2010-08-31 14:41:46.271660000 +0200
@@ -0,0 +1,276 @@
+project(cyrus-sasl)
+cmake_minimum_required(VERSION 2.6.2)
+set(PACKAGE "cyrus-sasl")
+set(VERSION "2.1.22")
+set(PLUGINDESTINATION lib/sasl2)
+set(PLUGINDIR ${CMAKE_INSTALL_PREFIX}/${PLUGINDESTINATION})
+set(CONFIGDIR ${CMAKE_INSTALL_PREFIX}/${PLUGINDESTINATION})
+
+option(STATIC_PLUGIN "build the sasl plugins statically" ON)
+option(STATIC_LIBRARY "build the sasl library statically" ON)
+
+set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_CURRENT_SOURCE_DIR}/cmake/modules)
+
+if(WINCE)
+    find_package(Wcecompat REQUIRED)
+    include_directories(${WCECOMPAT_INCLUDE_DIR})
+    set(CMAKE_REQUIRED_INCLUDES ${CMAKE_REQUIRED_INCLUDES} ${WCECOMPAT_INCLUDE_DIR})
+    set(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} ${WCECOMPAT_LIBRARIES})
+endif(WINCE)
+
+include(CheckIncludeFiles)
+check_include_files(sys/socket.h   HAVE_SYS_SOCKET_H)
+check_include_files(syslog.h       HAVE_SYSLOG_H)
+check_include_files(getopt.h       HAVE_GETOPT_H)
+check_include_files(time.h         HAVE_TIME_H)
+check_include_files(unistd.h       HAVE_UNISTD_H)
+check_include_files(des.h          HAVE_DES_H)
+check_include_files(dirent.h       HAVE_DIRENT_H)
+check_include_files(dlfcn.h        HAVE_DLFCN_H)
+check_include_files(fcntl.h  HAVE_FCNTL_H)
+check_include_files(gssapi.h  HAVE_GSSAPI_H)
+check_include_files(inttypes.h  HAVE_INTTYPES_H)
+check_include_files(lber.h  HAVE_LBER_H)
+check_include_files(ldap.h  HAVE_LDAP_H)
+check_include_files(limits.h  HAVE_LIMITS_H)
+check_include_files(malloc.h  HAVE_MALLOC_H)
+check_include_files(memory.h  HAVE_MEMORY_H)
+check_include_files(ndir.h  HAVE_NDIR_H)
+check_include_files(pam/pam_appl.h  HAVE_PAM_PAM_APPL_H)
+check_include_files(paths.h  HAVE_PATHS_H)
+check_include_files(security/pam_appl.h  HAVE_SECURITY_PAM_APPL_H)
+check_include_files(stdarg.h  HAVE_STDARG_H)
+check_include_files(stdint.h  HAVE_STDINT_H)
+check_include_files(stdlib.h  HAVE_STDLIB_H)
+check_include_files(strings.h  HAVE_STRINGS_H)
+check_include_files(string.h  HAVE_STRING_H)
+check_include_files(sysexits.h  HAVE_SYSEXITS_H)
+check_include_files(syslog.h  HAVE_SYSLOG_H)
+check_include_files(sys/dir.h  HAVE_SYS_DIR_H)
+check_include_files(sys/file.h  HAVE_SYS_FILE_H)
+check_include_files(sys/ndir.h HAVE_SYS_NDIR_H)
+check_include_files(sys/param.h  HAVE_SYS_PARAM_H)
+check_include_files(sys/stat.h  HAVE_SYS_STAT_H)
+check_include_files(sys/time.h  HAVE_SYS_TIME_H)
+check_include_files(sys/types.h  HAVE_SYS_TYPES_H)
+check_include_files(sys/uio.h  HAVE_SYS_UIO_H)
+check_include_files(sys/wait.h HAVE_SYS_WAIT_H)
+check_include_files(unistd.h  HAVE_UNISTD_H)
+check_include_files(varargs.h  HAVE_VARARGS_H)
+
+include(CheckFunctionExists)
+check_function_exists(getaddrinfo       HAVE_GETADDRINFO)
+check_function_exists(getnameinfo       HAVE_GETNAMEINFO)
+check_function_exists(syslog            HAVE_SYSLOG)
+#check_function_exists(getpid            HAVE_GETPID)
+check_function_exists(gettimeofday      HAVE_GETTIMEOFDAY)
+check_include_files(snprintf            HAVE_SNPRINTF)
+if(WIN32)
+  set(HAVE_SNPRINTF 1)
+endif(WIN32)
+
+include(CheckSymbolExists)
+check_symbol_exists(SOCKLENT_T        "sys/socket.h"               SOCKLENT_T)
+
+# TODO: HAVE_SOCKADDR_SA_LEN
+
+if(WIN32)
+  add_definitions(-DWIN32)
+  add_definitions(-D_CRT_SECURE_NO_DEPRECATE)
+  add_definitions(-D_CRT_NONSTDC_NO_DEPRECATE)
+  set(HIER_DELIMITER '\\\\')
+else(WIN32)
+  set(HIER_DELIMITER '/')
+endif(WIN32)
+
+if(CMAKE_COMPILER_IS_GNUCC)
+  set(HAVE___ATTRIBUTE__ 1)
+endif(CMAKE_COMPILER_IS_GNUCC)
+
+configure_file(${CMAKE_SOURCE_DIR}/config.h.cmake ${CMAKE_CURRENT_BINARY_DIR}/config.h)
+
+if(WIN32 AND NOT WINCE)
+set(additional_link_libs ws2_32)
+endif(WIN32 AND NOT WINCE)
+
+if(WINCE)
+set(additional_link_libs ws2 ${WCECOMPAT_LIBRARIES})
+endif(WINCE)
+
+set(plugin_SRCS
+  plugins/plugin_common.c
+  plugins/plugin_common.h
+)
+
+if(STATIC_LIBRARY)
+    set(LIBSASL_STATIC 1)
+    configure_file(include/prop.h.cmake ${CMAKE_CURRENT_BINARY_DIR}/prop.h)
+    message(STATUS "building static library version")
+    add_definitions(-DLIBSASL_STATIC)
+endif(STATIC_LIBRARY)
+
+if(STATIC_PLUGIN)
+    add_definitions(-DSTATIC_PLUGIN
+                    -DSTATIC_ANONYMOUS
+                    -DSTATIC_CRAMMD5
+                    -DSTATIC_DIGESTMD5
+                    -DSTATIC_LOGIN
+                    -DSTATIC_PLAIN)
+
+    #
+    # ANONYMOUS
+    #
+    set(anonymous_SRCS
+      plugins/anonymous.c
+      plugins/anonymous_init.c
+    )
+    #
+    # LOGIN
+    #
+    set(login_SRCS
+      plugins/login.c
+      plugins/login_init.c
+    )
+    #
+    # PLAIN
+    #
+    set(plain_SRCS
+      plugins/plain.c
+      plugins/plain_init.c
+    )
+    #
+    # CRAMMD5
+    #
+    set(crammd5_SRCS
+      plugins/cram.c
+      plugins/crammd5_init.c
+    )
+    #
+    # DIGESTMD5
+    #
+    set(digestmd5_SRCS
+      plugins/digestmd5.c
+      plugins/digestmd5_init.c
+    )
+    set(plugin_SRCS ${plugin_SRCS} ${anonymous_SRCS} ${login_SRCS} ${plain_SRCS} ${crammd5_SRCS} ${digestmd5_SRCS})
+endif(STATIC_PLUGIN)
+
+set(sasl_SRCS
+  lib/auxprop.c
+  lib/canonusr.c
+  lib/checkpw.c
+  lib/client.c
+  lib/common.c
+  lib/config.c
+  lib/external.c
+  lib/getaddrinfo.c
+  lib/getnameinfo.c
+  lib/getsubopt.c
+  lib/md5.c
+  lib/saslutil.c
+  lib/server.c
+  lib/seterror.c
+)
+if(NOT HAVE_SNPRINTF)
+  list(APPEND sasl_SRCS lib/snprintf.c)
+endif(NOT HAVE_SNPRINTF)
+if(WIN32)
+  list(APPEND sasl_SRCS lib/windlopen.c)
+else(WIN32)
+  list(APPEND sasl_SRCS lib/dlopen.c)
+endif(WIN32)
+
+set(sasl_HDRS
+  lib/saslint.h
+  lib/staticopen.h
+)
+set(sasl_inc_HDRS
+  include/exits.h
+  include/gai.h
+  include/hmac-md5.h
+  include/md5.h
+  include/md5global.h
+  include/sasl.h
+  include/saslplug.h
+  include/saslutil.h
+)
+
+include_directories(
+  ${CMAKE_SOURCE_DIR}/include
+  ${CMAKE_CURRENT_BINARY_DIR}
+)
+if(STATIC_LIBRARY)
+    add_library(sasl2 STATIC ${sasl_SRCS} ${sasl_HDRS} ${sasl_inc_HDRS} ${plugin_SRCS})
+    install(FILES ${CMAKE_CURRENT_BINARY_DIR}/prop.h DESTINATION include/sasl)
+else(STATIC_LIBRARY)
+    add_library(sasl2 SHARED ${sasl_SRCS} ${sasl_HDRS} ${sasl_inc_HDRS} ${plugin_SRCS})
+    set_target_properties(sasl2 PROPERTIES DEFINE_SYMBOL LIBSASL_EXPORTS)
+    install(FILES include/prop.h DESTINATION include/sasl)
+endif(STATIC_LIBRARY)
+target_link_libraries(sasl2 ${additional_link_libs})
+install(TARGETS sasl2 RUNTIME DESTINATION bin LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)
+install(FILES ${sasl_inc_HDRS} DESTINATION include/sasl)
+
+if(NOT STATIC_PLUGIN)
+    #
+    # ANONYMOUS
+    #
+    set(anonymous_SRCS
+      plugins/anonymous.c
+      plugins/anonymous_init.c
+    )
+    add_library(saslANONYMOUS MODULE ${anonymous_SRCS} ${plugin_SRCS})
+    target_link_libraries(saslANONYMOUS sasl2 ${additional_link_libs})
+    install(TARGETS saslANONYMOUS DESTINATION ${PLUGINDESTINATION})
+
+    #
+    # LOGIN
+    #
+    set(login_SRCS
+      plugins/login.c
+      plugins/login_init.c
+    )
+    add_library(saslLOGIN MODULE ${login_SRCS} ${plugin_SRCS})
+    target_link_libraries(saslLOGIN sasl2 ${additional_link_libs})
+    install(TARGETS saslLOGIN DESTINATION ${PLUGINDESTINATION})
+
+    #
+    # PLAIN
+    #
+    set(plain_SRCS
+      plugins/plain.c
+      plugins/plain_init.c
+    )
+    add_library(saslPLAIN MODULE ${plain_SRCS} ${plugin_SRCS})
+    target_link_libraries(saslPLAIN sasl2 ${additional_link_libs})
+    install(TARGETS saslPLAIN DESTINATION ${PLUGINDESTINATION})
+
+    #
+    # CRAMMD5
+    #
+    set(crammd5_SRCS
+      plugins/cram.c
+      plugins/crammd5_init.c
+    )
+    add_library(saslCRAMMD5 MODULE ${crammd5_SRCS} ${plugin_SRCS})
+    target_link_libraries(saslCRAMMD5 sasl2 ${additional_link_libs})
+    install(TARGETS saslCRAMMD5 DESTINATION ${PLUGINDESTINATION})
+
+    #
+    # DIGESTMD5
+    #
+    set(digestmd5_SRCS
+      plugins/digestmd5.c
+      plugins/digestmd5_init.c
+    )
+    add_library(saslDIGESTMD5 MODULE ${digestmd5_SRCS} ${plugin_SRCS})
+    target_link_libraries(saslDIGESTMD5 sasl2 ${additional_link_libs})
+    install(TARGETS saslDIGESTMD5 DESTINATION ${PLUGINDESTINATION})
+endif(NOT STATIC_PLUGIN)
+
+#
+# Pluginviewer
+#
+add_executable(sasl2_pluginviewer utils/pluginviewer.c)
+target_link_libraries(sasl2_pluginviewer sasl2 ${additional_link_libs})
+install(TARGETS sasl2_pluginviewer DESTINATION bin)
diff -Nru cyrus-sasl-2.1.22.orig/config.h.cmake cyrus-sasl-2.1.22/config.h.cmake
--- cyrus-sasl-2.1.22.orig/config.h.cmake	1970-01-01 01:00:00.000000000 +0100
+++ cyrus-sasl-2.1.22/config.h.cmake	2010-10-06 18:51:42.114171900 +0200
@@ -0,0 +1,210 @@
+#ifndef CONFIG_H
+#define CONFIG_H
+/* Name of package */
+#cmakedefine PACKAGE "@PACKAGE@"
+
+#cmakedefine VERSION "@VERSION@"
+
+/* Define to 1 if you have the <des.h> header file. */
+#cmakedefine HAVE_DES_H
+
+/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
+   */
+#cmakedefine HAVE_DIRENT_H
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#cmakedefine HAVE_DLFCN_H
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#cmakedefine HAVE_FCNTL_H
+
+/* Define if you have the gssapi.h header file */
+#cmakedefine HAVE_GSSAPI_H
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#cmakedefine HAVE_INTTYPES_H
+
+/* Define to 1 if you have the <lber.h> header file. */
+#cmakedefine HAVE_LBER_H
+
+/* Define to 1 if you have the <ldap.h> header file. */
+#cmakedefine HAVE_LDAP_H
+
+/* Define to 1 if you have the <limits.h> header file. */
+#cmakedefine HAVE_LIMITS_H
+
+/* Define to 1 if you have the <malloc.h> header file. */
+#cmakedefine HAVE_MALLOC_H
+
+/* Define to 1 if you have the <memory.h> header file. */
+#cmakedefine HAVE_MEMORY_H
+
+/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
+#cmakedefine HAVE_NDIR_H
+
+/* Define to 1 if you have the <pam/pam_appl.h> header file. */
+#cmakedefine HAVE_PAM_PAM_APPL_H
+
+/* Define to 1 if you have the <paths.h> header file. */
+#cmakedefine HAVE_PATHS_H
+
+/* Define to 1 if you have the <security/pam_appl.h> header file. */
+#cmakedefine HAVE_SECURITY_PAM_APPL_H
+
+/* Define to 1 if you have the <stdarg.h> header file. */
+#cmakedefine HAVE_STDARG_H
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#cmakedefine HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#cmakedefine HAVE_STDLIB_H
+
+/* Define to 1 if you have the <strings.h> header file. */
+#cmakedefine HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#cmakedefine HAVE_STRING_H
+
+/* Define to 1 if you have the <sysexits.h> header file. */
+#cmakedefine HAVE_SYSEXITS_H
+
+/* Define to 1 if you have the <syslog.h> header file. */
+#cmakedefine HAVE_SYSLOG_H
+
+/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
+   */
+#cmakedefine HAVE_SYS_DIR_H
+
+/* Define to 1 if you have the <sys/file.h> header file. */
+#cmakedefine HAVE_SYS_FILE_H
+
+/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
+   */
+#cmakedefine HAVE_SYS_NDIR_H
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#cmakedefine HAVE_SYS_PARAM_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#cmakedefine HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#cmakedefine HAVE_SYS_TIME_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#cmakedefine HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <sys/uio.h> header file. */
+#cmakedefine HAVE_SYS_UIO_H
+
+/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
+#cmakedefine HAVE_SYS_WAIT_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#cmakedefine HAVE_UNISTD_H
+
+/* Define to 1 if you have the <varargs.h> header file. */
+#cmakedefine HAVE_VARARGS_H
+
+/* Do we have a getnameinfo() function? */
+#cmakedefine HAVE_GETNAMEINFO 1
+
+/* Do we have a getaddrinfo() function? */
+#cmakedefine HAVE_GETADDRINFO 1
+
+/* Do we have a getpid() function? */
+#cmakedefine HAVE_GETPID 1
+
+/* Do we have a gettimeofday() function? */
+#cmakedefine HAVE_GETTIMEOFDAY 1
+
+/* Do we have a gettimeofday() function? */
+#cmakedefine HAVE_SNPRINTF 1
+
+/* Do we have a socklen_t? */
+#undef HAVE_SOCKLEN_T
+#ifndef HAVE_SOCKLEN_T
+typedef unsigned int socklen_t;
+#endif /* HAVE_SOCKLEN_T */
+
+/* define if your compiler has __attribute__ */
+#cmakedefine HAVE___ATTRIBUTE__ 1
+#ifndef HAVE___ATTRIBUTE__
+/* Can't use attributes... */
+#define __attribute__(foo)
+#endif
+
+#cmakedefine HAVE_SYS_SOCKET_H 1
+#ifdef HAVE_SYS_SOCKET_H
+  #include <sys/socket.h>
+#endif
+
+#cmakedefine HAVE_SYSLOG 1
+
+#cmakedefine HAVE_TIME_H 1
+
+#cmakedefine HAVE_GETOPT_H 1
+
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+
+/* Defined in RFC 1035. max strlen is only 253 due to length bytes. */
+#ifndef MAXHOSTNAMELEN
+# define MAXHOSTNAMELEN  255
+#endif
+
+/* Runtime plugin location */
+#cmakedefine PLUGINDIR "@PLUGINDIR@"
+#cmakedefine CONFIGDIR "@CONFIGDIR@"
+
+#ifndef HAVE_GETADDRINFO
+#define	getaddrinfo	    sasl_getaddrinfo
+#define	freeaddrinfo	sasl_freeaddrinfo
+#define	gai_strerror	sasl_gai_strerror
+#endif
+
+#ifndef HAVE_GETNAMEINFO
+#define	getnameinfo	    sasl_getnameinfo
+#endif
+
+#if !defined(HAVE_GETNAMEINFO) || !defined(HAVE_GETADDRINFO)
+#include "gai.h"
+#endif
+
+#ifndef AI_NUMERICHOST   /* support glibc 2.0.x */
+#define AI_NUMERICHOST  4
+#define NI_NUMERICHOST  2
+#define NI_NAMEREQD     4
+#define NI_NUMERICSERV  8
+#endif
+
+#ifndef WIN32
+# include <netdb.h>
+# ifdef HAVE_SYS_PARAM_H
+#  include <sys/param.h>
+# endif
+#else /* WIN32 */
+# include <winsock2.h>
+# ifndef strncasecmp
+#  define strncasecmp strnicmp
+# endif
+# ifndef strcasecmp
+#  define strcasecmp stricmp
+# endif
+# ifndef snprintf
+#  define snprintf _snprintf
+# endif
+
+/* Registry key that contains the locations of the plugins */
+# define SASL_ROOT_KEY "SOFTWARE\\Carnegie Mellon\\Project Cyrus\\SASL Library"
+# define SASL_PLUGIN_PATH_ATTR "SearchPath"
+# define SASL_CONF_PATH_ATTR "ConfFile"
+
+#endif /* WIN32 */
+
+#ifndef HIER_DELIMITER
+# define HIER_DELIMITER @HIER_DELIMITER@
+#endif
+#endif
diff -Nru cyrus-sasl-2.1.22.orig/include/gai.h cyrus-sasl-2.1.22/include/gai.h
--- cyrus-sasl-2.1.22.orig/include/gai.h	2006-04-10 15:36:20.000000000 +0200
+++ cyrus-sasl-2.1.22/include/gai.h	2010-07-25 20:43:51.977312400 +0200
@@ -54,6 +54,8 @@
 #ifndef _GAI_H_
 #define _GAI_H_
 
+#include "prop.h"
+
 #ifndef NI_MAXHOST
 #define	NI_MAXHOST	1025
 #endif
@@ -73,6 +75,7 @@
 #ifndef AI_PASSIVE
 #define AI_PASSIVE	1
 #define AI_CANONNAME	2
+#if !(defined(_MSC_VER) && _MSC_VER >= 1600)
 struct addrinfo {
 	int	ai_flags;	/* AI_PASSIVE, AI_CANONNAME */
 	int	ai_family;	/* PF_xxx */
@@ -84,21 +87,22 @@
 	struct addrinfo *ai_next;	/* next structure in linked list */
 };
 #endif
+#endif
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 #ifndef HAVE_GETNAMEINFO
-int	getnameinfo(const struct sockaddr *, socklen_t, char *,
+LIBSASL_API int	getnameinfo(const struct sockaddr *, socklen_t, char *,
 		    size_t, char *, size_t, int);
 #endif
 
 #ifndef HAVE_GETADDRINFO
-int	getaddrinfo(const char *, const char *,
+LIBSASL_API int	getaddrinfo(const char *, const char *,
 		    const struct addrinfo *, struct addrinfo **);
-void	freeaddrinfo(struct addrinfo *);
-char	*gai_strerror(int);
+LIBSASL_API void	freeaddrinfo(struct addrinfo *);
+LIBSASL_API char	*gai_strerror(int);
 #endif
 
 #ifdef __cplusplus
diff -Nru cyrus-sasl-2.1.22.orig/include/prop.h cyrus-sasl-2.1.22/include/prop.h
--- cyrus-sasl-2.1.22.orig/include/prop.h	2003-12-12 01:47:22.000000000 +0100
+++ cyrus-sasl-2.1.22/include/prop.h	2010-08-31 11:40:06.383222000 +0200
@@ -33,18 +33,22 @@
 /* Under Unix, life is simpler: we just need to mark library functions
  * as extern.  (Technically, we don't even have to do that.) */
 #ifdef WIN32
-# ifdef LIBSASL_EXPORTS
-#  define LIBSASL_API  __declspec(dllexport)
-# else /* LIBSASL_EXPORTS */
-#  define LIBSASL_API  __declspec(dllimport)
-# endif /* LIBSASL_EXPORTS */
+# ifndef LIBSASL_STATIC
+#  ifdef LIBSASL_EXPORTS
+#   define LIBSASL_API  __declspec(dllexport)
+#  else /* LIBSASL_EXPORTS */
+#   define LIBSASL_API  __declspec(dllimport)
+#  endif /* LIBSASL_EXPORTS */
+# else /* LIBSASL_STATIC */
+#  define LIBSASL_API
+# endif
 #else /* WIN32 */
 # define LIBSASL_API extern
 #endif /* WIN32 */
 
 /* Same as above, but used during a variable declaration. Only Unix definition
  * is different, as we can't assign an initial value to an extern variable */ 
-#ifdef WIN32
+#if defined(WIN32) && !defined(LIBSASL_STATIC)
 # ifdef LIBSASL_EXPORTS
 #  define LIBSASL_VAR  __declspec(dllexport)
 # else /* LIBSASL_EXPORTS */
diff -Nru cyrus-sasl-2.1.22.orig/include/prop.h.cmake cyrus-sasl-2.1.22/include/prop.h.cmake
--- cyrus-sasl-2.1.22.orig/include/prop.h.cmake	1970-01-01 01:00:00.000000000 +0100
+++ cyrus-sasl-2.1.22/include/prop.h.cmake	2010-08-31 14:42:13.475216000 +0200
@@ -0,0 +1,193 @@
+/* prop.h -- property request/response management routines
+ *
+ * Author: Chris Newman
+ * Removal of implementation-specific details by: Rob Siemborski
+ *
+ * This is intended to be used to create a list of properties to request,
+ * and _then_ request values for all properties.  Any change to the request
+ * list will discard any existing values.  This assumption allows a very
+ * efficient and simple memory model.  This was designed for SASL API auxiliary
+ * property support, but would be fine for other contexts where this property
+ * model is appropriate.
+ *
+ * The "struct propctx" is allocated by prop_new and is a fixed size structure.
+ * If a prop_init() call were added, it would be reasonable to embed a "struct
+ * propctx" in another structure.  prop_new also allocates a pool of memory
+ * (in the vbase field) which will be used for an array of "struct propval"
+ * to list all the requested properties.
+ *
+ * Properties may be multi-valued.
+ */
+
+#ifndef PROP_H
+#define PROP_H 1
+
+#cmakedefine LIBSASL_STATIC 1
+
+/* The following ifdef block is the standard way of creating macros
+ * which make exporting from a DLL simpler. All files within this DLL
+ * are compiled with the LIBSASL_EXPORTS symbol defined on the command
+ * line. this symbol should not be defined on any project that uses
+ * this DLL. This way any other project whose source files include
+ * this file see LIBSASL_API functions as being imported from a DLL,
+ * wheras this DLL sees symbols defined with this macro as being
+ * exported.  */
+/* Under Unix, life is simpler: we just need to mark library functions
+ * as extern.  (Technically, we don't even have to do that.) */
+#ifdef WIN32
+# ifndef LIBSASL_STATIC
+#  ifdef LIBSASL_EXPORTS
+#   define LIBSASL_API  __declspec(dllexport)
+#  else /* LIBSASL_EXPORTS */
+#   define LIBSASL_API  __declspec(dllimport)
+#  endif /* LIBSASL_EXPORTS */
+# else /* LIBSASL_STATIC */
+#  define LIBSASL_API
+# endif
+#else /* WIN32 */
+# define LIBSASL_API extern
+#endif /* WIN32 */
+
+/* Same as above, but used during a variable declaration. Only Unix definition
+ * is different, as we can't assign an initial value to an extern variable */ 
+#if defined(WIN32) && !defined(LIBSASL_STATIC)
+# ifdef LIBSASL_EXPORTS
+#  define LIBSASL_VAR  __declspec(dllexport)
+# else /* LIBSASL_EXPORTS */
+#  define LIBSASL_VAR  __declspec(dllimport)
+# endif /* LIBSASL_EXPORTS */
+#else /* WIN32 */
+# define LIBSASL_VAR
+#endif /* WIN32 */
+
+/* the resulting structure for property values
+ */
+struct propval {
+    const char *name;	 /* name of property; NULL = end of list */
+                         /* same pointer used in request will be used here */
+    const char **values; /* list of strings, values == NULL if property not
+			  * found, *values == NULL if property found with
+			  * no values */
+    unsigned nvalues;    /* total number of value strings */
+    unsigned valsize;	 /* total size in characters of all value strings */
+};
+
+/*
+ * private internal structure
+ */
+#define PROP_DEFAULT 4		/* default number of propvals to assume */
+struct propctx;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* create a property context
+ *  estimate -- an estimate of the storage needed for requests & responses
+ *              0 will use module default
+ * returns a new property context on success and NULL on any error
+ */
+LIBSASL_API struct propctx *prop_new(unsigned estimate);
+
+/* create new propctx which duplicates the contents of an existing propctx
+ * returns SASL_OK on success
+ * possible other return values include: SASL_NOMEM, SASL_BADPARAM
+ */
+LIBSASL_API int prop_dup(struct propctx *src_ctx, struct propctx **dst_ctx);
+
+/* Add property names to request
+ *  ctx       -- context from prop_new()
+ *  names     -- list of property names; must persist until context freed
+ *               or requests cleared (This extends to other contexts that
+ *               are dup'ed from this one, and their children, etc)
+ *
+ * NOTE: may clear values from context as side-effect
+ * returns SASL_OK on success
+ * possible other return values include: SASL_NOMEM, SASL_BADPARAM
+ */
+LIBSASL_API int prop_request(struct propctx *ctx, const char **names);
+
+/* return array of struct propval from the context
+ *  return value persists until next call to
+ *   prop_request, prop_clear or prop_dispose on context
+ *
+ *  returns NULL on error
+ */
+LIBSASL_API const struct propval *prop_get(struct propctx *ctx);
+
+/* Fill in an array of struct propval based on a list of property names
+ *  return value persists until next call to
+ *   prop_request, prop_clear or prop_dispose on context
+ *  returns number of matching properties which were found (values != NULL)
+ *  if a name requested here was never requested by a prop_request, then
+ *  the name field of the associated vals entry will be set to NULL
+ *
+ * The vals array MUST be atleast as long as the names array.
+ *
+ * returns # of matching properties on success
+ * possible other return values include: SASL_BADPARAM
+ */
+LIBSASL_API int prop_getnames(struct propctx *ctx, const char **names,
+		  struct propval *vals);
+
+/* clear values and optionally requests from property context
+ *  ctx      -- property context
+ *  requests -- 0 = don't clear requests, 1 = clear requests
+ */
+LIBSASL_API void prop_clear(struct propctx *ctx, int requests);
+
+/* erase the value of a property
+ */
+LIBSASL_API void prop_erase(struct propctx *ctx, const char *name);
+
+/* dispose of property context
+ *  ctx      -- is disposed and set to NULL; noop if ctx or *ctx is NULL
+ */
+LIBSASL_API void prop_dispose(struct propctx **ctx);
+
+
+/****fetcher interfaces****/
+
+/* format the requested property names into a string
+ *  ctx    -- context from prop_new()/prop_request()
+ *  sep    -- separator between property names (unused if none requested)
+ *  seplen -- length of separator, if < 0 then strlen(sep) will be used
+ *  outbuf -- output buffer
+ *  outmax -- maximum length of output buffer including NUL terminator
+ *  outlen -- set to length of output string excluding NUL terminator
+ * returns SASL_OK on success
+ * returns SASL_BADPARAM or amount of additional space needed on failure
+ */
+LIBSASL_API int prop_format(struct propctx *ctx, const char *sep, int seplen,
+		char *outbuf, unsigned outmax, unsigned *outlen);
+
+/* add a property value to the context
+ *  ctx    -- context from prop_new()/prop_request()
+ *  name   -- name of property to which value will be added
+ *            if NULL, add to the same name as previous prop_set/setvals call
+ *  value  -- a value for the property; will be copied into context
+ *            if NULL, remove existing values
+ *  vallen -- length of value, if <= 0 then strlen(value) will be used
+ * returns SASL_OK on success
+ * possible error return values include: SASL_BADPARAM, SASL_NOMEM
+ */
+LIBSASL_API int prop_set(struct propctx *ctx, const char *name,
+	     const char *value, int vallen);
+
+/* set the values for a property
+ *  ctx    -- context from prop_new()/prop_request()
+ *  name   -- name of property to which value will be added
+ *            if NULL, add to the same name as previous prop_set/setvals call
+ *  values -- array of values, ending in NULL.  Each value is a NUL terminated
+ *            string
+ * returns SASL_OK on success
+ * possible error return values include: SASL_BADPARAM, SASL_NOMEM
+ */
+LIBSASL_API int prop_setvals(struct propctx *ctx, const char *name,
+		 const char **values);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PROP_H */
diff -Nru cyrus-sasl-2.1.22.orig/lib/auxprop.c cyrus-sasl-2.1.22/lib/auxprop.c
--- cyrus-sasl-2.1.22.orig/lib/auxprop.c	2006-03-14 15:23:55.000000000 +0100
+++ cyrus-sasl-2.1.22/lib/auxprop.c	2010-08-31 15:58:57.386544600 +0200
@@ -851,15 +851,15 @@
 			  unsigned flags,
 			  const char *user, unsigned ulen) 
 {
-    sasl_getopt_t *getopt;
+    sasl_getopt_t *_getopt;
     int ret, found = 0;
     void *context;
     const char *plist = NULL;
     auxprop_plug_list_t *ptr;
 
     if(_sasl_getcallback(sparams->utils->conn,
-			 SASL_CB_GETOPT, &getopt, &context) == SASL_OK) {
-	ret = getopt(context, NULL, "auxprop_plugin", &plist, NULL);
+			 SASL_CB_GETOPT, &_getopt, &context) == SASL_OK) {
+	ret = _getopt(context, NULL, "auxprop_plugin", &plist, NULL);
 	if(ret != SASL_OK) plist = NULL;
     }
 
@@ -917,7 +917,7 @@
 int sasl_auxprop_store(sasl_conn_t *conn,
 		       struct propctx *ctx, const char *user)
 {
-    sasl_getopt_t *getopt;
+    sasl_getopt_t *_getopt;
     int ret, found = 0;
     void *context;
     const char *plist = NULL;
@@ -933,9 +933,9 @@
 	userlen = (unsigned) strlen(user);
     }
     
-    /* Pickup getopt callback from the connection, if conn is not NULL */
-    if(_sasl_getcallback(conn, SASL_CB_GETOPT, &getopt, &context) == SASL_OK) {
-	ret = getopt(context, NULL, "auxprop_plugin", &plist, NULL);
+    /* Pickup _getopt callback from the connection, if conn is not NULL */
+    if(_sasl_getcallback(conn, SASL_CB_GETOPT, &_getopt, &context) == SASL_OK) {
+	ret = _getopt(context, NULL, "auxprop_plugin", &plist, NULL);
 	if(ret != SASL_OK) plist = NULL;
     }
 
diff -Nru cyrus-sasl-2.1.22.orig/lib/canonusr.c cyrus-sasl-2.1.22/lib/canonusr.c
--- cyrus-sasl-2.1.22.orig/lib/canonusr.c	2004-02-21 00:54:51.000000000 +0100
+++ cyrus-sasl-2.1.22/lib/canonusr.c	2010-08-31 15:59:38.610902500 +0200
@@ -76,7 +76,7 @@
     sasl_server_conn_t *sconn = NULL;
     sasl_client_conn_t *cconn = NULL;
     sasl_canon_user_t *cuser_cb;
-    sasl_getopt_t *getopt;
+    sasl_getopt_t *_getopt;
     void *context;
     int result;
     const char *plugin_name = NULL;
@@ -123,9 +123,9 @@
 
     /* which plugin are we supposed to use? */
     result = _sasl_getcallback(conn, SASL_CB_GETOPT,
-			       &getopt, &context);
-    if(result == SASL_OK && getopt) {
-	getopt(context, NULL, "canon_user_plugin", &plugin_name, NULL);
+			       &_getopt, &context);
+    if(result == SASL_OK && _getopt) {
+	_getopt(context, NULL, "canon_user_plugin", &plugin_name, NULL);
     }
 
     if(!plugin_name) {
diff -Nru cyrus-sasl-2.1.22.orig/lib/checkpw.c cyrus-sasl-2.1.22/lib/checkpw.c
--- cyrus-sasl-2.1.22.orig/lib/checkpw.c	2006-03-13 19:30:41.000000000 +0100
+++ cyrus-sasl-2.1.22/lib/checkpw.c	2010-08-31 16:00:17.434123100 +0200
@@ -548,7 +548,7 @@
     char *query_end = query;
     int s;
     struct sockaddr_un srvaddr;
-    sasl_getopt_t *getopt;
+    sasl_getopt_t *_getopt;
     void *context;
     char pwpath[sizeof(srvaddr.sun_path)];
     const char *p = NULL;
@@ -558,8 +558,8 @@
 #endif
 
     /* check to see if the user configured a rundir */
-    if (_sasl_getcallback(conn, SASL_CB_GETOPT, &getopt, &context) == SASL_OK) {
-	getopt(context, NULL, "saslauthd_path", &p, NULL);
+    if (_sasl_getcallback(conn, SASL_CB_GETOPT, &_getopt, &context) == SASL_OK) {
+	_getopt(context, NULL, "saslauthd_path", &p, NULL);
     }
     if (p) {
 	strncpy(pwpath, p, sizeof(pwpath));
@@ -915,15 +915,15 @@
 				      const char *user_realm __attribute__((unused)))
 {
     const char *p = NULL;
-    sasl_getopt_t *getopt;
+    sasl_getopt_t *_getopt;
     void *context;
     int result = SASL_FAIL;
     char *query = NULL;
     int sock = -1;
 
     /* check to see if the user configured a rundir */
-    if (_sasl_getcallback(conn, SASL_CB_GETOPT, &getopt, &context) == SASL_OK) {
-	getopt(context, NULL, "authdaemond_path", &p, NULL);
+    if (_sasl_getcallback(conn, SASL_CB_GETOPT, &_getopt, &context) == SASL_OK) {
+	_getopt(context, NULL, "authdaemond_path", &p, NULL);
     }
     if (!p) {
 	/*
diff -Nru cyrus-sasl-2.1.22.orig/lib/common.c cyrus-sasl-2.1.22/lib/common.c
--- cyrus-sasl-2.1.22.orig/lib/common.c	Wed Apr 19 18:39:59 2006
+++ cyrus-sasl-2.1.22/lib/common.c	2010-08-31 16:01:15.441440900 +0200
@@ -850,7 +850,7 @@
 int sasl_getprop(sasl_conn_t *conn, int propnum, const void **pvalue)
 {
   int result = SASL_OK;
-  sasl_getopt_t *getopt;
+  sasl_getopt_t *_getopt;
   void *context;
   
   if (! conn) return SASL_BADPARAM;
@@ -865,7 +865,7 @@
       *(unsigned **)pvalue = &conn->oparams.maxoutbuf;
       break;
   case SASL_GETOPTCTX:
-      result = _sasl_getcallback(conn, SASL_CB_GETOPT, &getopt, &context);
+      result = _sasl_getcallback(conn, SASL_CB_GETOPT, &_getopt, &context);
       if(result != SASL_OK) break;
       
       *(void **)pvalue = context;
@@ -1435,6 +1435,7 @@
 #ifdef WIN32
     /* for win32, try using the GetUserName standard call */
     {
+#ifndef _WIN32_WCE
 	DWORD i;
 	BOOL rval;
 	static char sender[128];
@@ -1446,6 +1447,11 @@
 		if (len) *len = strlen(sender);
 		return SASL_OK;
 	}
+#else
+    static char *sender = "wince";
+    *result = sender;
+    return SASL_OK;
+#endif
     }
 #endif /* WIN32 */
     return SASL_FAIL;
@@ -2399,6 +2405,8 @@
 		     &cbData);
 
     switch (ValueType) {
+// There are no enviroment variables under wince
+#ifndef _WIN32_WCE
     case REG_EXPAND_SZ:
         /* : A random starting guess */
         cbExpandedData = cbData + 1024;
@@ -2447,7 +2455,7 @@
         ExpandedValueData = NULL;
 
         break;
-
+#endif
     case REG_MULTI_SZ:
         tmp = ValueData;
 
diff -Nru cyrus-sasl-2.1.22.orig/lib/dlopen.c cyrus-sasl-2.1.22/lib/dlopen.c
--- cyrus-sasl-2.1.22.orig/lib/dlopen.c	2005-03-15 14:33:30.000000000 +0100
+++ cyrus-sasl-2.1.22/lib/dlopen.c	2010-08-31 11:18:47.142053600 +0200
@@ -56,7 +56,7 @@
 #include <sasl.h>
 #include "saslint.h"
 
-#ifndef PIC
+#if !defined(PIC) || defined(STATIC_PLUGIN)
 #include <saslplug.h>
 #include "staticopen.h"
 #endif
@@ -393,7 +393,7 @@
     DIR *dp;
     struct dirent *dir;
 #endif
-#ifndef PIC
+#if !defined(PIC) || defined(STATIC_PLUGIN)
     add_plugin_t *add_plugin;
     _sasl_plug_type type;
     _sasl_plug_rec *p;
@@ -408,7 +408,7 @@
 	|| ! verifyfile_cb->proc)
 	return SASL_BADPARAM;
 
-#ifndef PIC
+#if !defined(PIC) || defined(STATIC_PLUGIN)
     /* do all the static plugins first */
 
     for(cur_ep = entrypoints; cur_ep->entryname; cur_ep++) {
@@ -435,7 +435,7 @@
 	    	result = add_plugin(p->name, p->plug);
 	}
     }
-#endif /* !PIC */
+#endif /* !PIC || STATIC_PLUGIN */
 
 /* only do the following if:
  * 
diff -Nru cyrus-sasl-2.1.22.orig/lib/saslutil.c cyrus-sasl-2.1.22/lib/saslutil.c
--- cyrus-sasl-2.1.22.orig/lib/saslutil.c	Mon Mar 13 18:26:36 2006
+++ cyrus-sasl-2.1.22/lib/saslutil.c	Mon Jul  5 16:13:56 2010
@@ -469,7 +469,7 @@
     memset(buf, 0, len);
 }
 
-#ifdef WIN32
+#ifdef _MSC_VER
 /***************************************************************************** 
  * 
  *  MODULE NAME : GETOPT.C 
@@ -515,11 +515,11 @@
  * The opstring argument points to a string of option characters; if an 
  * option character is followed by a colon, the option is expected to have 
  * an argument that may or may not be separated from it by white space. 
- * The external variable optarg is set to point to the start of the option 
+ * The external variable sasl_optarg is set to point to the start of the option 
  * argument on return from getopt(). 
  * 
- * The getopt() function places in optind the argv index of the next argument 
- * to be processed.  The system initializes the external variable optind to 
+ * The getopt() function places in sasl_optind the argv index of the next argument 
+ * to be processed.  The system initializes the external variable sasl_optind to 
  * 1 before the first call to getopt(). 
  * 
  * When all options have been processed (that is, up to the first nonoption 
@@ -529,7 +529,7 @@
  * 
  * The getopt() function returns a question mark (?) when it encounters an 
  * option character not included in opstring.  This error message can be 
- * disabled by setting opterr to zero.  Otherwise, it returns the option 
+ * disabled by setting sasl_opterr to zero.  Otherwise, it returns the option 
  * character that was detected. 
  * 
  * If the special option "--" is detected, or all options have been 
@@ -543,15 +543,19 @@
 #include <string.h>                 /* for strchr() */ 
  
 /* static (global) variables that are specified as exported by getopt() */ 
-__declspec(dllexport) char *optarg = NULL;    /* pointer to the start of the option argument  */ 
-__declspec(dllexport) int   optind = 1;       /* number of the next argv[] to be evaluated    */ 
-__declspec(dllexport) int   opterr = 1;       /* non-zero if a question mark should be returned */
-
+#ifndef LIBSASL_STATIC
+#define SASL_GETOPT_EXPORT __declspec(dllexport)
+#else
+#define SASL_GETOPT_EXPORT
+#endif
+SASL_GETOPT_EXPORT char *sasl_optarg = NULL;    /* pointer to the start of the option argument  */ 
+SASL_GETOPT_EXPORT int   sasl_optind = 1;       /* number of the next argv[] to be evaluated    */ 
+SASL_GETOPT_EXPORT int   sasl_opterr = 1;       /* non-zero if a question mark should be returned */
  
 /* handle possible future character set concerns by putting this in a macro */ 
 #define _next_char(string)  (char)(*(string+1)) 
  
-int getopt(int argc, char *argv[], char *opstring) 
+int _getopt(int argc, char *argv[], char *opstring) 
 { 
     static char *pIndexPosition = NULL; /* place inside current argv string */ 
     char *pArgString = NULL;        /* where to start from next */ 
@@ -568,7 +572,7 @@
  
     if (pArgString == NULL) { 
         /* we didn't leave off in the middle of an argv string */ 
-        if (optind >= argc) { 
+        if (sasl_optind >= argc) { 
             /* more command-line arguments than the argument count */ 
             pIndexPosition = NULL;  /* not in the middle of anything */ 
             return EOF;             /* used up all command-line arguments */ 
@@ -577,12 +581,12 @@
         /*--------------------------------------------------------------------- 
          * If the next argv[] is not an option, there can be no more options. 
          *-------------------------------------------------------------------*/ 
-        pArgString = argv[optind++]; /* set this to the next argument ptr */ 
+        pArgString = argv[sasl_optind++]; /* set this to the next argument ptr */ 
  
         if (('/' != *pArgString) && /* doesn't start with a slash or a dash? */ 
             ('-' != *pArgString)) { 
-            --optind;               /* point to current arg once we're done */ 
-            optarg = NULL;          /* no argument follows the option */ 
+            --sasl_optind;               /* point to current arg once we're done */ 
+            sasl_optarg = NULL;          /* no argument follows the option */ 
             pIndexPosition = NULL;  /* not in the middle of anything */ 
             return EOF;             /* used up all the command-line flags */ 
         } 
@@ -590,7 +594,7 @@
         /* check for special end-of-flags markers */ 
         if ((strcmp(pArgString, "-") == 0) || 
             (strcmp(pArgString, "--") == 0)) { 
-            optarg = NULL;          /* no argument follows the option */ 
+            sasl_optarg = NULL;          /* no argument follows the option */ 
             pIndexPosition = NULL;  /* not in the middle of anything */ 
             return EOF;             /* encountered the special flag */ 
         } 
@@ -600,18 +604,18 @@
  
     if (':' == *pArgString) {       /* is it a colon? */ 
         /*--------------------------------------------------------------------- 
-         * Rare case: if opterr is non-zero, return a question mark; 
+         * Rare case: if sasl_opterr is non-zero, return a question mark; 
          * otherwise, just return the colon we're on. 
          *-------------------------------------------------------------------*/ 
-        return (opterr ? (int)'?' : (int)':'); 
+        return (sasl_opterr ? (int)'?' : (int)':'); 
     } 
     else if ((pOptString = strchr(opstring, *pArgString)) == 0) { 
         /*--------------------------------------------------------------------- 
          * The letter on the command-line wasn't any good. 
          *-------------------------------------------------------------------*/ 
-        optarg = NULL;              /* no argument follows the option */ 
+        sasl_optarg = NULL;              /* no argument follows the option */ 
         pIndexPosition = NULL;      /* not in the middle of anything */ 
-        return (opterr ? (int)'?' : (int)*pArgString); 
+        return (sasl_opterr ? (int)'?' : (int)*pArgString); 
     } 
     else { 
         /*--------------------------------------------------------------------- 
@@ -620,26 +624,26 @@
         if (':' == _next_char(pOptString)) { /* is the next letter a colon? */ 
             /* It is a colon.  Look for an argument string. */ 
             if ('\0' != _next_char(pArgString)) {  /* argument in this argv? */ 
-                optarg = &pArgString[1];   /* Yes, it is */ 
+                sasl_optarg = &pArgString[1];   /* Yes, it is */ 
             } 
             else { 
                 /*------------------------------------------------------------- 
                  * The argument string must be in the next argv. 
                  * But, what if there is none (bad input from the user)? 
-                 * In that case, return the letter, and optarg as NULL. 
+                 * In that case, return the letter, and sasl_optarg as NULL. 
                  *-----------------------------------------------------------*/ 
-                if (optind < argc) 
-                    optarg = argv[optind++]; 
+                if (sasl_optind < argc) 
+                    sasl_optarg = argv[sasl_optind++]; 
                 else { 
-                    optarg = NULL; 
-                    return (opterr ? (int)'?' : (int)*pArgString); 
+                    sasl_optarg = NULL; 
+                    return (sasl_opterr ? (int)'?' : (int)*pArgString); 
                 } 
             } 
             pIndexPosition = NULL;  /* not in the middle of anything */ 
         } 
         else { 
             /* it's not a colon, so just return the letter */ 
-            optarg = NULL;          /* no argument follows the option */ 
+            sasl_optarg = NULL;          /* no argument follows the option */ 
             pIndexPosition = pArgString;    /* point to the letter we're on */ 
         } 
         return (int)*pArgString;    /* return the letter that matched */ 
@@ -659,6 +663,8 @@
 	register c;
 	static char pbuf[PASSWORD_MAX];
 
+//There is no console under wince
+#ifndef _WIN32_WCE    
 	fprintf(stderr, "%s", prompt); (void) fflush(stderr);
 	for (p=pbuf; (c = _getch())!=13 && c!=EOF;) {
 		if (p < &pbuf[sizeof(pbuf)-1])
@@ -666,6 +672,9 @@
 	}
 	*p = '\0';
 	fprintf(stderr, "\n"); (void) fflush(stderr);
+#else
+    *pbuf = '\0';
+#endif    
 	return(pbuf);
 }
 
diff -Nru cyrus-sasl-2.1.22.orig/lib/server.c cyrus-sasl-2.1.22/lib/server.c
--- cyrus-sasl-2.1.22.orig/lib/server.c	2006-05-17 18:46:13.000000000 +0200
+++ cyrus-sasl-2.1.22/lib/server.c	2010-08-31 16:04:08.025312100 +0200
@@ -687,7 +687,7 @@
     const sasl_callback_t *vf;
     const char *pluginfile = NULL;
 #ifdef PIC
-    sasl_getopt_t *getopt;
+    sasl_getopt_t *_getopt;
     void *context;
 #endif
 
@@ -757,11 +757,11 @@
 #ifdef PIC
     /* delayed loading of plugins? (DSO only, as it doesn't
      * make much [any] sense to delay in the static library case) */
-    if (_sasl_getcallback(NULL, SASL_CB_GETOPT, &getopt, &context) 
+    if (_sasl_getcallback(NULL, SASL_CB_GETOPT, &_getopt, &context) 
 	   == SASL_OK) {
 	/* No sasl_conn_t was given to getcallback, so we provide the
 	 * global callbacks structure */
-	ret = getopt(&global_callbacks, NULL, "plugin_list", &pluginfile, NULL);
+	ret = _getopt(&global_callbacks, NULL, "plugin_list", &pluginfile, NULL);
     }
 #endif
     
@@ -814,7 +814,7 @@
 		 unsigned passlen)
 {
     const char *dotrans = "n";
-    sasl_getopt_t *getopt;
+    sasl_getopt_t *_getopt;
     int result = SASL_OK;
     void *context;
     unsigned flags = 0;
@@ -826,9 +826,9 @@
 	PARAMERROR(conn);
 
     /* check if this is enabled: default to false */
-    if (_sasl_getcallback(conn, SASL_CB_GETOPT, &getopt, &context) == SASL_OK)
+    if (_sasl_getcallback(conn, SASL_CB_GETOPT, &_getopt, &context) == SASL_OK)
     {
-	getopt(context, NULL, "auto_transition", &dotrans, NULL);
+	_getopt(context, NULL, "auto_transition", &dotrans, NULL);
 	if (dotrans == NULL) dotrans = "n";
     }
 
@@ -884,7 +884,7 @@
   int result;
   sasl_server_conn_t *serverconn;
   sasl_utils_t *utils;
-  sasl_getopt_t *getopt;
+  sasl_getopt_t *_getopt;
   void *context;
   const char *log_level, *auto_trans;
 
@@ -965,9 +965,9 @@
   serverconn->sparams->callbacks = callbacks;
 
   log_level = auto_trans = NULL;
-  if(_sasl_getcallback(*pconn, SASL_CB_GETOPT, &getopt, &context) == SASL_OK) {
-    getopt(context, NULL, "log_level", &log_level, NULL);
-    getopt(context, NULL, "auto_transition", &auto_trans, NULL);
+  if(_sasl_getcallback(*pconn, SASL_CB_GETOPT, &_getopt, &context) == SASL_OK) {
+    _getopt(context, NULL, "log_level", &log_level, NULL);
+    _getopt(context, NULL, "auto_transition", &auto_trans, NULL);
   }
   serverconn->sparams->log_level = log_level ? atoi(log_level) : SASL_LOG_ERR;
 
@@ -1008,7 +1008,7 @@
     int ret;
     int myflags;
     context_list_t *cur;
-    sasl_getopt_t *getopt;
+    sasl_getopt_t *_getopt;
     void *context;
     sasl_ssf_t minssf = 0;
 
@@ -1022,11 +1022,11 @@
     plug = mech->m.plug;
 
     /* get the list of allowed mechanisms (default = all) */
-    if (_sasl_getcallback(conn, SASL_CB_GETOPT, &getopt, &context)
+    if (_sasl_getcallback(conn, SASL_CB_GETOPT, &_getopt, &context)
             == SASL_OK) {
 	const char *mlist = NULL;
 
-	getopt(context, NULL, "mech_list", &mlist, NULL);
+	_getopt(context, NULL, "mech_list", &mlist, NULL);
 
 	/* if we have a list, check the plugin against it */
 	if (mlist) {
@@ -1635,7 +1635,7 @@
 {
     sasl_server_conn_t *s_conn = (sasl_server_conn_t *) conn;
     int result;
-    sasl_getopt_t *getopt;
+    sasl_getopt_t *_getopt;
     sasl_server_userdb_checkpass_t *checkpass_cb;
     void *context;
     const char *mlist = NULL, *mech = NULL;
@@ -1656,9 +1656,9 @@
     }
 
     /* figure out how to check (i.e. auxprop or saslauthd or pwcheck) */
-    if (_sasl_getcallback(conn, SASL_CB_GETOPT, &getopt, &context)
+    if (_sasl_getcallback(conn, SASL_CB_GETOPT, &_getopt, &context)
             == SASL_OK) {
-        getopt(context, NULL, "pwcheck_method", &mlist, NULL);
+        _getopt(context, NULL, "pwcheck_method", &mlist, NULL);
     }
 
     if(!mlist) mlist = DEFAULT_CHECKPASS_MECH;
@@ -1767,7 +1767,7 @@
     int result=SASL_NOMECH;
     const char *mlist = NULL, *mech = NULL;
     void *context;
-    sasl_getopt_t *getopt;
+    sasl_getopt_t *_getopt;
     struct sasl_verify_password_s *v;
     
     /* check params */
@@ -1779,9 +1779,9 @@
     if(!service) service = conn->service;
     
     /* figure out how to check (i.e. auxprop or saslauthd or pwcheck) */
-    if (_sasl_getcallback(conn, SASL_CB_GETOPT, &getopt, &context)
+    if (_sasl_getcallback(conn, SASL_CB_GETOPT, &_getopt, &context)
             == SASL_OK) {
-        getopt(context, NULL, "pwcheck_method", &mlist, NULL);
+        _getopt(context, NULL, "pwcheck_method", &mlist, NULL);
     }
 
     if(!mlist) mlist = DEFAULT_CHECKPASS_MECH;
diff -Nru cyrus-sasl-2.1.22.orig/lib/windlopen.c cyrus-sasl-2.1.22/lib/windlopen.c
--- cyrus-sasl-2.1.22.orig/lib/windlopen.c	Mon Oct 20 15:19:59 2003
+++ cyrus-sasl-2.1.22/lib/windlopen.c	2010-08-31 11:18:47.144053700 +0200
@@ -50,6 +50,11 @@
 #include <sasl.h>
 #include "saslint.h"
 
+#ifdef STATIC_PLUGIN
+#include <saslplug.h>
+#include "staticopen.h"
+#endif
+
 #define DLL_SUFFIX	".dll"
 #define DLL_MASK	"*" DLL_SUFFIX
 #define DLL_MASK_LEN	5
@@ -69,6 +74,10 @@
 		       const char *entryname,
 		       void **entry_point) 
 {
+#ifdef _WIN32_WCE
+    wchar_t *wentryname;
+    wentryname = wce_mbtowc(entryname);
+#endif
     if(entryname == NULL) {
 	_sasl_log(NULL, SASL_LOG_ERR,
 		  "no entryname in _sasl_locate_entry");
@@ -86,8 +95,13 @@
 		  "no entrypoint output pointer in _sasl_locate_entry");
 	return SASL_BADPARAM;
     }
-
+    
+#ifndef _WIN32_WCE
     *entry_point = GetProcAddress(library, entryname);
+#else
+    *entry_point = GetProcAddressW(library, wentryname);
+    free(wentryname);
+#endif
 
     if (*entry_point == NULL) {
 #if 0 /* This message appears to confuse people */
@@ -159,19 +173,27 @@
 		       const sasl_callback_t *verifyfile_cb)
 {
     int result;
+    const add_plugin_list_t *cur_ep;
+
+#ifdef STATIC_PLUGIN /* STATIC_PLUGIN 2 */
+    add_plugin_t *add_plugin;
+    _sasl_plug_type type;
+    _sasl_plug_rec *p;
+#else /* STATIC_PLUGIN 2 */
     char cur_dir[PATH_MAX], full_name[PATH_MAX+2], prefix[PATH_MAX+2];
 				/* 1 for '\\' 1 for trailing '\0' */
+
     char * pattern;
     char c;
     int pos;
     const char *path=NULL;
     int position;
-    const add_plugin_list_t *cur_ep;
     struct stat statbuf;		/* filesystem entry information */
     intptr_t fhandle;			/* file handle for _findnext function */
     struct _finddata_t finddata;	/* data returned by _findnext() */
     size_t prefix_len;
-
+#endif /* STATIC_PLUGIN 2 */
+    
     if (! entrypoints
 	|| ! getpath_cb
 	|| getpath_cb->id != SASL_CB_GETPATH
@@ -181,6 +203,33 @@
 	|| ! verifyfile_cb->proc)
 	return SASL_BADPARAM;
 
+#ifdef STATIC_PLUGIN /* STATIC_PLUGIN 3 */
+    /* do all the static plugins first */
+    for(cur_ep = entrypoints; cur_ep->entryname; cur_ep++) {
+
+	/* What type of plugin are we looking for? */
+	if(!strcmp(cur_ep->entryname, "sasl_server_plug_init")) {
+	    type = SERVER;
+	    add_plugin = (add_plugin_t *)sasl_server_add_plugin;
+	} else if (!strcmp(cur_ep->entryname, "sasl_client_plug_init")) {
+	    type = CLIENT;
+	    add_plugin = (add_plugin_t *)sasl_client_add_plugin;
+	} else if (!strcmp(cur_ep->entryname, "sasl_auxprop_plug_init")) {
+	    type = AUXPROP;
+	    add_plugin = (add_plugin_t *)sasl_auxprop_add_plugin;
+	} else if (!strcmp(cur_ep->entryname, "sasl_canonuser_init")) {
+	    type = CANONUSER;
+	    add_plugin = (add_plugin_t *)sasl_canonuser_add_plugin;
+	} else {
+	    /* What are we looking for then? */
+	    return SASL_FAIL;
+	}
+	for (p=_sasl_static_plugins; p->type; p++) {
+	    if(type == p->type)
+	    	result = add_plugin(p->name, p->plug);
+	}
+    }
+#else /* STATIC_PLUGIN 3 */
     /* get the path to the plugins */
     result = ((sasl_getpath_t *)(getpath_cb->proc))(getpath_cb->context,
 						    &path);
@@ -257,9 +306,12 @@
 	    }
 
 /* : Check that it is not a directory */
+/* It is not implemented in wince */
+#ifndef _WIN32_WCE
 	    if ((finddata.attrib & _A_SUBDIR) == _A_SUBDIR) {
 		continue;
 	    }
+#endif
 
 /* : Construct full name from prefix and name */
 
@@ -287,6 +339,7 @@
 	_findclose (fhandle);
 
     } while ((c!='=') && (c!=0));
+#endif /* STATIC_PLUGIN 3 */
 
     return SASL_OK;
 }
diff -Nru cyrus-sasl-2.1.22.orig/plugins/anonymous_init.c cyrus-sasl-2.1.22/plugins/anonymous_init.c
--- cyrus-sasl-2.1.22.orig/plugins/anonymous_init.c	2006-05-19 16:49:30.000000000 +0200
+++ cyrus-sasl-2.1.22/plugins/anonymous_init.c	2010-08-31 14:12:01.252562700 +0200
@@ -20,7 +20,7 @@
 #include <sasl_anonymous_plugin_decl.h>
 #endif
 
-#ifdef WIN32
+#if defined(WIN32) && !defined(STATIC_PLUGIN)
 BOOL APIENTRY DllMain( HANDLE hModule, 
                        DWORD  ul_reason_for_call, 
                        LPVOID lpReserved
@@ -36,8 +36,7 @@
     }
     return TRUE;
 }
-#endif
 
 SASL_CLIENT_PLUG_INIT( anonymous )
 SASL_SERVER_PLUG_INIT( anonymous )
-
+#endif
diff -Nru cyrus-sasl-2.1.22.orig/plugins/crammd5_init.c cyrus-sasl-2.1.22/plugins/crammd5_init.c
--- cyrus-sasl-2.1.22.orig/plugins/crammd5_init.c	2006-05-19 16:49:30.000000000 +0200
+++ cyrus-sasl-2.1.22/plugins/crammd5_init.c	2010-08-31 14:11:48.820851700 +0200
@@ -20,7 +20,7 @@
 #include <sasl_crammd5_plugin_decl.h>
 #endif
 
-#ifdef WIN32
+#if defined(WIN32) && !defined(STATIC_PLUGIN)
 BOOL APIENTRY DllMain( HANDLE hModule, 
                        DWORD  ul_reason_for_call, 
                        LPVOID lpReserved
@@ -36,8 +36,7 @@
     }
     return TRUE;
 }
-#endif
 
 SASL_CLIENT_PLUG_INIT( crammd5 )
 SASL_SERVER_PLUG_INIT( crammd5 )
-
+#endif
diff -Nru cyrus-sasl-2.1.22.orig/plugins/digestmd5_init.c cyrus-sasl-2.1.22/plugins/digestmd5_init.c
--- cyrus-sasl-2.1.22.orig/plugins/digestmd5_init.c	2006-05-19 16:49:30.000000000 +0200
+++ cyrus-sasl-2.1.22/plugins/digestmd5_init.c	2010-08-31 14:11:33.662984700 +0200
@@ -20,7 +20,7 @@
 #include <sasl_digestmd5_plugin_decl.h>
 #endif
 
-#ifdef WIN32
+#if defined(WIN32) && !defined(STATIC_PLUGIN)
 BOOL APIENTRY DllMain( HANDLE hModule, 
                        DWORD  ul_reason_for_call, 
                        LPVOID lpReserved
@@ -36,8 +36,7 @@
     }
     return TRUE;
 }
-#endif
 
 SASL_CLIENT_PLUG_INIT( digestmd5 )
 SASL_SERVER_PLUG_INIT( digestmd5 )
-
+#endif
diff -Nru cyrus-sasl-2.1.22.orig/plugins/login_init.c cyrus-sasl-2.1.22/plugins/login_init.c
--- cyrus-sasl-2.1.22.orig/plugins/login_init.c	2006-05-19 16:49:30.000000000 +0200
+++ cyrus-sasl-2.1.22/plugins/login_init.c	2010-08-31 14:12:24.362884600 +0200
@@ -20,7 +20,7 @@
 #include <sasl_login_plugin_decl.h>
 #endif
 
-#ifdef WIN32
+#if defined(WIN32) && !defined(STATIC_PLUGIN)
 BOOL APIENTRY DllMain( HANDLE hModule, 
                        DWORD  ul_reason_for_call, 
                        LPVOID lpReserved
@@ -36,8 +36,7 @@
     }
     return TRUE;
 }
-#endif
 
 SASL_CLIENT_PLUG_INIT( login )
 SASL_SERVER_PLUG_INIT( login )
-
+#endif
diff -Nru cyrus-sasl-2.1.22.orig/plugins/plain_init.c cyrus-sasl-2.1.22/plugins/plain_init.c
--- cyrus-sasl-2.1.22.orig/plugins/plain_init.c	2006-05-19 16:49:30.000000000 +0200
+++ cyrus-sasl-2.1.22/plugins/plain_init.c	2010-08-31 14:12:09.585039300 +0200
@@ -20,7 +20,7 @@
 #include <sasl_plain_plugin_decl.h>
 #endif
 
-#ifdef WIN32
+#if defined(WIN32) && !defined(STATIC_PLUGIN)
 BOOL APIENTRY DllMain( HANDLE hModule, 
                        DWORD  ul_reason_for_call, 
                        LPVOID lpReserved
@@ -36,8 +36,7 @@
     }
     return TRUE;
 }
-#endif
 
 SASL_CLIENT_PLUG_INIT( plain )
 SASL_SERVER_PLUG_INIT( plain )
-
+#endif
diff -Nru cyrus-sasl-2.1.22.orig/plugins/plugin_common.c cyrus-sasl-2.1.22/plugins/plugin_common.c
--- cyrus-sasl-2.1.22.orig/plugins/plugin_common.c	Wed Jun 23 18:43:37 2004
+++ cyrus-sasl-2.1.22/plugins/plugin_common.c	2010-08-31 11:12:40.213066500 +0200
@@ -819,7 +819,7 @@
 
 void _plug_snprintf_os_info (char * osbuf, int osbuf_len)
 {
-#ifdef WIN32
+#if defined(WIN32) && !defined(_WIN32_WCE)
     OSVERSIONINFOEX versioninfo;
     char *sysname;
 
@@ -905,7 +905,45 @@
 
 SKIP_OS_INFO:
     ;
+#elif defined(_WIN32_WCE)
 
+    OSVERSIONINFO version;
+    char *sysname;
+    
+      version.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
+    if (!GetVersionEx (&version))
+    {
+        *osbuf = 0;
+        return;
+    }
+    
+     switch (version.dwPlatformId) {
+		case VER_PLATFORM_WIN32s:
+		    sysname = "Windows 3.1";
+		    break;
+		case VER_PLATFORM_WIN32_WINDOWS:
+            if (version.dwMinorVersion == 0)
+                sysname = "Windows 95";
+            else
+                sysname = "Windows 98";
+		    break;
+		case VER_PLATFORM_WIN32_NT:
+		    sysname = "Windows NT";
+		    break;
+        case VER_PLATFORM_WIN32_CE:
+		    sysname = "Windows CE";
+		    break;
+		default:
+		    sysname = "Unknown Windows 9X/ME series";
+		    break;
+	    }
+    
+    snprintf(osbuf, osbuf_len,
+	     "%s %s (Build %u)",
+	     sysname,
+	     version.szCSDVersion,
+	     version.dwBuildNumber
+	     );
 #else /* !WIN32 */
     struct utsname os;
 
diff -Nru cyrus-sasl-2.1.22.orig/utils/pluginviewer.c cyrus-sasl-2.1.22/utils/pluginviewer.c
--- cyrus-sasl-2.1.22.orig/utils/pluginviewer.c	Wed May 17 16:46:17 2006
+++ cyrus-sasl-2.1.22/utils/pluginviewer.c	2010-08-31 11:57:28.282815300 +0200
@@ -49,9 +49,16 @@
 #include <stdlib.h>
 #ifdef WIN32
 # include <winsock.h>
-__declspec(dllimport) char *optarg;
-__declspec(dllimport) int optind;
+# ifndef LIBSASL_STATIC
+__declspec(dllimport) char *sasl_optarg;
+__declspec(dllimport) int sasl_optind;
 __declspec(dllimport) int getsubopt(char **optionp, const char * const *tokens, char **valuep);
+#define HAVE_GETSUBOPT
+#else
+extern char *sasl_optarg;
+extern int sasl_optind;
+extern int getsubopt(char **optionp, const char * const *tokens, char **valuep);
+# endif /* LIBSASL_STATIC */
 #else  /* WIN32 */
 # include <netinet/in.h>
 #endif /* WIN32 */
@@ -84,6 +91,95 @@
 #include <unistd.h>
 #endif
 
+#if !defined(HAVE_GETOPT_H)
+
+#ifndef HAVE_SASL_OPTIND
+int	 sasl_optind = 1;		/* index into parent argv vector */
+char	*sasl_optarg;		/* argument associated with option */
+#endif
+#if defined(LIBSASL_STATIC)
+extern int sasl_opterr; /* if error message should be printed */
+#else
+int sasl_opterr = 1;/* if error message should be printed */
+#endif
+int optopt,			/* character checked for validity */
+    optreset;		/* reset_sasl_getopt */
+#define	BADCH	(int)'?'
+#define	BADARG	(int)':'
+#define	EMSG	""
+
+/*
+ *_sasl_getopt --
+ *	Parse argc/argv argument vector.
+ */
+int
+_sasl_getopt(nargc, nargv, ostr)
+	int nargc;
+	char * const *nargv;
+	const char *ostr;
+{
+	static char *place = EMSG;		/* option letter processing */
+	char *oli;				/* option letter list index */
+
+	if (optreset || !*place) {		/* update scanning pointer */
+		optreset = 0;
+		if (sasl_optind >= nargc || *(place = nargv[sasl_optind]) != '-') {
+			place = EMSG;
+			return (-1);
+		}
+		if (place[1] && *++place == '-') {	/* found "--" */
+			++sasl_optind;
+			place = EMSG;
+			return (-1);
+		}
+	}					/* option letter okay? */
+	if ((optopt = (int)*place++) == (int)':' ||
+	    !(oli = strchr(ostr, optopt))) {
+		/*
+		 * if the user didn't specify '-' as an option,
+		 * assume it means -1.
+		 */
+		if (optopt == (int)'-')
+			return (-1);
+		if (!*place)
+			++sasl_optind;
+		if (sasl_opterr && *ostr != ':')
+			(void)fprintf(stderr,
+			    "%s: illegal option -- %c\n", nargv[0], optopt);
+		return (BADCH);
+	}
+	if (*++oli != ':') {			/* don't need argument */
+		sasl_optarg = NULL;
+		if (!*place)
+			++sasl_optind;
+	}
+	else {					/* need an argument */
+		if (*place)			/* no white space */
+			sasl_optarg = place;
+		else if (nargc <= ++sasl_optind) {	/* no arg */
+			place = EMSG;
+			if (*ostr == ':')
+				return (BADARG);
+			if (sasl_opterr)
+				(void)fprintf(stderr,
+				    "%s: option requires an argument -- %c\n",
+				    nargv[0], optopt);
+			return (BADCH);
+		}
+	 	else				/* white space */
+			sasl_optarg = nargv[sasl_optind];
+		place = EMSG;
+		++sasl_optind;
+	}
+	return (optopt);			/* dump back option letter */
+}
+#else
+# define sasl_opterr opterr
+# define sasl_optind optind
+# define sasl_optarg optarg
+# define _sasl_getopt getopt
+#endif
+
 #ifndef HAVE_GETSUBOPT
 int getsubopt(char **optionp, const char * const *tokens, char **valuep);
 #endif
@@ -413,7 +509,7 @@
     secprops.maxbufsize = SAMPLE_SEC_BUF_SIZE;
     secprops.max_ssf = UINT_MAX;
 
-    while ((c = getopt(argc, argv, "acshb:e:m:f:p:x:?")) != EOF)
+    while ((c =_sasl_getopt(argc, argv, "acshb:e:m:f:p:x:?")) != EOF)
         switch (c) {
         case 'a':
 	    list_auxprop_plugins = 1;
@@ -421,7 +517,7 @@
 	    break;
 
         case 'x':
-            auxprop_mech = optarg;
+            auxprop_mech = sasl_optarg;
             break;
 
         case 'c':
@@ -435,7 +531,7 @@
 	    break;
 
         case 'b':
-            options = optarg;
+            options = sasl_optarg;
             while (*options != '\0') {
 	        switch(getsubopt(&options, (const char * const *)bit_subopts, &value)) {
 	        case OPT_MIN:
@@ -460,7 +556,7 @@
             break;
 
         case 'e':
-            options = optarg;
+            options = sasl_optarg;
             while (*options != '\0') {
 	        switch(getsubopt(&options, (const char * const *)ext_subopts, &value)) {
 	        case OPT_EXT_SSF:
@@ -485,11 +581,11 @@
             break;
 
         case 'm':
-            mech = optarg;
+            mech = sasl_optarg;
             break;
 
         case 'f':
-            options = optarg;
+            options = sasl_optarg;
             while (*options != '\0') {
 	        switch(getsubopt(&options, (const char * const *)flag_subopts, &value)) {
 	        case OPT_NOPLAIN:
@@ -519,7 +615,7 @@
             break;
 
         case 'p':
-            searchpath = optarg;
+            searchpath = sasl_optarg;
             break;
 
         default:			/* unknown flag */
@@ -527,7 +623,7 @@
             break;
         }
 
-    if (optind != argc) {
+    if (sasl_optind != argc) {
         /* We don't *have* extra arguments */
         errflag = 1;
     }
@@ -578,7 +674,7 @@
         ++callback;
     }
 
-    /* getopt */
+    /*_sasl_getopt */
     callback->id = SASL_CB_GETOPT;
     callback->proc = &sasl_getopt;
     callback->context = NULL;
@@ -665,7 +761,7 @@
             saslfail(result, "Setting security properties", NULL);
         }
 
-        /* This will use getopt callback, which is using the "mech" global variable */
+        /* This will use_sasl_getopt callback, which is using the "mech" global variable */
         result = sasl_listmech(server_conn,
 			    ext_authid,
 			    NULL,
@@ -758,7 +854,7 @@
             saslfail(result, "Setting security properties", NULL);
         }
 
-        /* This will use getopt callback, which is using the "mech" global variable */
+        /* This will use_sasl_getopt callback, which is using the "mech" global variable */
         result = sasl_listmech(client_conn,
 			    ext_authid,
 			    NULL,
