From 1ff5ae0e4796c912c4310375681a16b841ebdd3d Mon Sep 17 00:00:00 2001
From: Andre Heinecke <Andre Heinecke aheinecke@intevation.de>
Date: Fri, 22 Oct 2010 12:16:18 +0200
Subject: [PATCH] Replace qeventdispatcher

    Add a more easy to debug and battery saving eventdispatcher.
    Created by Marcus Brinkmann.
---
 mkspecs/wince60standard-armv4i-msvc2005/qmake.conf |    2 +-
 src/corelib/kernel/qeventdispatcher_win.cpp        | 1435 +++++++++-----------
 src/corelib/kernel/qeventdispatcher_win_p.h        |   49 +-
 3 files changed, 694 insertions(+), 792 deletions(-)

diff --git a/mkspecs/wince60standard-armv4i-msvc2005/qmake.conf b/mkspecs/wince60standard-armv4i-msvc2005/qmake.conf
index 3bb18af..8c61a10 100644
--- a/mkspecs/wince60standard-armv4i-msvc2005/qmake.conf
+++ b/mkspecs/wince60standard-armv4i-msvc2005/qmake.conf
@@ -17,7 +17,7 @@ QMAKE_LFLAGS_WINDOWS	= /SUBSYSTEM:WINDOWSCE,6.00 /MACHINE:THUMB
 QMAKE_LFLAGS_DLL        = /SUBSYSTEM:WINDOWSCE,6.00 /MACHINE:THUMB /DLL /SAFESEH:NO
 QMAKE_LIBFLAGS_RELEASE	= /LTCG
 QMAKE_LIBS              = corelibc.lib coredll.lib
-QMAKE_LIBS_CORE         = libcmt.lib corelibc.lib ole32.lib oleaut32.lib uuid.lib commctrl.lib coredll.lib winsock.lib
+QMAKE_LIBS_CORE         = libcmt.lib corelibc.lib ole32.lib oleaut32.lib uuid.lib commctrl.lib coredll.lib winsock.lib ws2.lib
 QMAKE_LIBS_GUI          = ceshell.lib ole32.lib $$QMAKE_LIBS_CORE
 QMAKE_LIBS_NETWORK      = ws2.lib $$QMAKE_LIBS_GUI
 QMAKE_LIBS_OPENGL       = 
diff --git a/src/corelib/kernel/qeventdispatcher_win.cpp b/src/corelib/kernel/qeventdispatcher_win.cpp
index 153ccdf..f05dcc3 100644
--- a/src/corelib/kernel/qeventdispatcher_win.cpp
+++ b/src/corelib/kernel/qeventdispatcher_win.cpp
@@ -39,6 +39,8 @@
 **
 ****************************************************************************/
 
+#include <winsock2.h>
+
 #include "qeventdispatcher_win_p.h"
 
 #include "qcoreapplication.h"
@@ -49,6 +51,7 @@
 #include "qsocketnotifier.h"
 #include "qvarlengtharray.h"
 #include "qwineventnotifier_p.h"
+#include "private/qpodlist_p.h"
 
 #include "qabstracteventdispatcher_p.h"
 #include "qcoreapplication_p.h"
@@ -60,18 +63,6 @@ QT_BEGIN_NAMESPACE
 HINSTANCE qWinAppInst();
 extern uint qGlobalPostedEventsCount();
 
-#ifndef TIME_KILL_SYNCHRONOUS
-#  define TIME_KILL_SYNCHRONOUS 0x0100
-#endif
-
-#ifndef QS_RAWINPUT
-# ifdef Q_OS_WINCE
-#  define QS_RAWINPUT 0x0000
-# else
-#  define QS_RAWINPUT 0x0400
-# endif
-#endif
-
 #ifndef WM_TOUCH
 #  define WM_TOUCH 0x0240
 #endif
@@ -82,326 +73,109 @@ extern uint qGlobalPostedEventsCount();
 #endif
 #endif // QT_NO_GESTURES
 
-enum {
-    WM_QT_SOCKETNOTIFIER = WM_USER,
-    WM_QT_SENDPOSTEDEVENTS = WM_USER + 1
-};
-
-#if defined(Q_OS_WINCE)
-QT_BEGIN_INCLUDE_NAMESPACE
-#include <winsock.h>
-// Asynchronous Winsocks ------------------------------------------
-#ifndef QT_NO_THREAD
-#include <qthread.h>
-#include <qmap.h>
-#include <qmutex.h>
-QT_END_INCLUDE_NAMESPACE
-
-//#define QCE_ASYNC_DEBUG
-
-namespace {
-    class SocketAsyncHandler;
-
-    class SocketAsyncHandler : public QThread
-    {
-    public:
-        SocketAsyncHandler();
-        ~SocketAsyncHandler();
-        void run();
-        void select(SOCKET sock, HWND handle, unsigned int msg, long ev);
-        void removeSelect(SOCKET sock);
-        void safeRemove(SOCKET sock);
-    private:
-        struct SockInfo {
-            HWND handle;
-            unsigned int msg;
-            long ev;
-        };
-        QMap<SOCKET, SockInfo> sockets;
-        QMutex mutex;
-        QWaitCondition cond;
-        bool supposedToDie;
-    };
-
-    SocketAsyncHandler::SocketAsyncHandler()
-        : supposedToDie(false)
-    {
-    }
-
-    SocketAsyncHandler::~SocketAsyncHandler()
-    {
-        mutex.lock();
-        supposedToDie = true;
-        mutex.unlock();
-        cond.wakeOne();
-        wait();
-        while (sockets.size() > 0)
-            removeSelect(sockets.begin().key());
-    }
-
-    void SocketAsyncHandler::removeSelect(SOCKET sock)
-    {
-        if (!sockets.contains(sock))
-            return;
-        sockets.remove(sock);
-        return;
-    }
-
-    void SocketAsyncHandler::safeRemove(SOCKET sock)
-    {
-        QMutexLocker locker(&mutex);
-        removeSelect(sock);
-    }
-
-    void SocketAsyncHandler::select(SOCKET sock, HWND handle, unsigned int msg, long ev)
-    {
-        QMutexLocker locker(&mutex);
-
-        if (sockets.contains(sock))
-            sockets.remove(sock);
-
-        SockInfo info;
-        info.handle = handle;
-        info.msg = msg;
-        info.ev = ev;
-        sockets.insert(sock, info);
-        cond.wakeOne();
-    }
-
-    void SocketAsyncHandler::run()
-    {
-        do {
-            mutex.lock();
-
-            while (!supposedToDie && sockets.isEmpty()) {
-                cond.wait(&mutex);
-            }
-
-            if (supposedToDie) {
-                mutex.unlock();
-                break;
-            }
-
-            // Copy current items to reduce lock time
-            // and to be able to use SendMessage
-            QMap<SOCKET, SockInfo> currentSockets = sockets;
-            mutex.unlock();
-
-            fd_set readS, writeS, exS;
-            FD_ZERO(&readS);
-            FD_ZERO(&writeS);
-            FD_ZERO(&exS);
-
-            int maxFd = 0;
-
-            for (QMap<SOCKET, SockInfo>::iterator it = currentSockets.begin(); it != currentSockets.end(); ++it) {
-                const SockInfo &info = it.value();
-                int socket = it.key();
-                maxFd = qMax(maxFd, socket);
-
-                if ((info.ev & FD_READ) || (info.ev & FD_CLOSE) || (info.ev & FD_ACCEPT))
-                    FD_SET(socket, &readS);
-                if ((info.ev & FD_WRITE)|| (info.ev & FD_CONNECT))
-                    FD_SET(socket, &writeS);
-                if (info.ev & FD_OOB)
-                    FD_SET(socket, &exS);
-            }
-
-            timeval timeout;
-            timeout.tv_sec = 0;
-            timeout.tv_usec = 50000;
-            int result = ::select(maxFd + 1, &readS, &writeS, &exS, &timeout);
-            if (result > 0) {
-                HWND handle;
-                unsigned int tmpMsg;
-                SOCKET sock;
-                HRESULT ret;
-                for (QMap<SOCKET, SockInfo>::const_iterator it = currentSockets.constBegin();
-                    it != currentSockets.constEnd(); ++it) {
-                        handle = (*it).handle;
-                        tmpMsg = (*it).msg;
-                        sock = it.key();
-                        if (FD_ISSET(sock, &readS))
-                            ret = SendMessage(handle, tmpMsg, sock, FD_READ);
-
-                        if (FD_ISSET(sock, &writeS))
-                            ret = SendMessage(handle, tmpMsg, sock, FD_WRITE);
-
-                        if (FD_ISSET(sock, &exS))
-                            ret = SendMessage(handle, tmpMsg, sock, FD_OOB);
-                }
-            }
-
-#ifdef QCE_ASYNC_DEBUG
-            else if (result == 0) { //timeout
-                qDebug("    WSAAsync select timeout");
-            } else if (result < 0) { // SocketError
-                // This might happen because of two reasons
-                // 1. We already closed a socket in between the copy and the select
-                //    and thus select() returns an error
-                // 2. Something is really wrong, then
-                //    ### Loop on all descriptors, try to select and remove the
-                //    ### broken one.
-                qWarning("WSAAsync select error %d", WSAGetLastError());
-            }
-#endif
-        } while(true);
-    }
-} // namespace
-
-Q_GLOBAL_STATIC(SocketAsyncHandler, qt_async_handler)
-
-int WSAAsyncSelect(SOCKET sock, HWND handle, unsigned int msg, long ev)
-{
-    if (sock == 0 || handle == 0 || handle == INVALID_HANDLE_VALUE) {
-        WSASetLastError(WSAEINVAL);
-        return SOCKET_ERROR;
-    }
-
-    if (msg == 0 && ev == 0)
-        qt_async_handler()->safeRemove(sock);
-    else
-        qt_async_handler()->select(sock, handle, msg, ev);
-
-    qt_async_handler()->start(QThread::LowPriority);
-    WSASetLastError(0);
-    return 0;
-}
-#else // QT_NO_THREAD
-int WSAAsyncSelect(SOCKET, HWND, unsigned int, long)
-{
-    return SOCKET_ERROR;
-}
-#endif
-#endif // Q_OS_WINCE
-
-class QEventDispatcherWin32Private;
-
-struct QSockNot {
-    QSocketNotifier *obj;
-    int fd;
-};
-typedef QHash<int, QSockNot *> QSNDict;
-
-struct WinTimerInfo {                           // internal timer info
-    QObject *dispatcher;
-    int timerId;
-    int interval;
-    QObject *obj;                               // - object to receive events
-    bool inTimerEvent;
-    int fastTimerId;
-};
-
-class QZeroTimerEvent : public QTimerEvent
-{
-public:
-    inline QZeroTimerEvent(int timerId)
-        : QTimerEvent(timerId)
-    { t = QEvent::ZeroTimerEvent; }
-};
-
-typedef QList<WinTimerInfo*>  WinTimerVec;      // vector of TimerInfo structs
-typedef QHash<int, WinTimerInfo*> WinTimerDict; // fast dict of timers
-
-#if !defined(DWORD_PTR) && !defined(Q_WS_WIN64)
-#define DWORD_PTR DWORD
-#endif
-
-typedef MMRESULT(WINAPI *ptimeSetEvent)(UINT, UINT, LPTIMECALLBACK, DWORD_PTR, UINT);
-typedef MMRESULT(WINAPI *ptimeKillEvent)(UINT);
-
-static ptimeSetEvent qtimeSetEvent = 0;
-static ptimeKillEvent qtimeKillEvent = 0;
 
 LRESULT QT_WIN_CALLBACK qt_internal_proc(HWND hwnd, UINT message, WPARAM wp, LPARAM lp);
 
-static void resolveTimerAPI()
-{
-    static bool triedResolve = false;
-    if (!triedResolve) {
-#ifndef QT_NO_THREAD
-        QMutexLocker locker(QMutexPool::globalInstanceGet(&triedResolve));
-        if (triedResolve)
-            return;
-#endif
-        triedResolve = true;
-#if !defined(Q_OS_WINCE)
-        qtimeSetEvent = (ptimeSetEvent)QSystemLibrary::resolve(QLatin1String("winmm"), "timeSetEvent");
-        qtimeKillEvent = (ptimeKillEvent)QSystemLibrary::resolve(QLatin1String("winmm"), "timeKillEvent");
-#else
-        qtimeSetEvent = (ptimeSetEvent)QSystemLibrary::resolve(QLatin1String("Mmtimer"), "timeSetEvent");
-        qtimeKillEvent = (ptimeKillEvent)QSystemLibrary::resolve(QLatin1String("Mmtimer"), "timeKillEvent");
-#endif
-    }
-}
-
+/* To integrate socket events into the event loop, we use
+   WSAEventSelect to connect socket events to a Windows event handle.
+   This way, WFMO can be used instead of select(), and asynchronous
+   operations can be avoided.  Because there can only be one such
+   event per socket, we have to merge all socket notification requests
+   for the same sockfd together with a single QSockNot.  */
+struct QSockNot
+{
+    int sockfd;
+    /* If not 0, Read/Write/OOB notifications are requested.  */
+    QSocketNotifier *obj[3];
+    /* Handle associated with WSAEventSelect.  */
+    HANDLE event;
+};
 
 class QEventDispatcherWin32Private : public QAbstractEventDispatcherPrivate
 {
     Q_DECLARE_PUBLIC(QEventDispatcherWin32)
+
 public:
     QEventDispatcherWin32Private();
     ~QEventDispatcherWin32Private();
 
-    DWORD threadId;
-
-    bool interrupt;
-
-    // internal window handle used for socketnotifiers/timers/etc
+    /* Internal window handle used system events (SendMessage,
+       DispatchMessage).  */
     HWND internalHwnd;
-    HHOOK getMessageHook;
 
-    // for controlling when to send posted events
-    QAtomicInt serialNumber;
-    int lastSerialNumber;
-#ifndef Q_OS_WINCE
-    int lastMessageTime;
-#endif
-    QAtomicInt wakeUps;
+    /* Set when new user events are posted.  It is automatically
+       reset.  */
+    HANDLE wakeUp;
 
-    // timers
-    WinTimerVec timerVec;
-    WinTimerDict timerDict;
-    void registerTimer(WinTimerInfo *t);
-    void unregisterTimer(WinTimerInfo *t, bool closingDown = false);
-    void sendTimerEvent(int timerId);
+    /* All registered socket notifiers (by sockfd).  */
+    QPodList<QSockNot *, 32> sockets;
+    /* Pending socket notifiers list.  */
+    QPodList<QSockNot *, 32> sn_pending_list;
 
-    // socket notifiers
-    QSNDict sn_read;
-    QSNDict sn_write;
-    QSNDict sn_except;
-    void doWsaAsyncSelect(int socket);
+    /* All registered Windows events.  */
+    QPodList<QWinEventNotifier *, 32> winEventNotifierList;
+    /* Pending Windows event notifiers list.  */
+    QPodList<QWinEventNotifier *, 32> wn_pending_list;
 
-    QList<QWinEventNotifier *> winEventNotifierList;
-    void activateEventNotifier(QWinEventNotifier * wen);
+    /* All registed timers.  */
+    QTimerInfoList timerList;
 
+    /* User input events queued due to ExcludeUserInputEvents.  */
     QList<MSG> queuedUserInputEvents;
-    QList<MSG> queuedSocketEvents;
+
+    /* Return from the event loop as soon as possible.  */
+    /* NOTE: There is a race condition here in all implementations
+       (unix, windows, ...): Because access to INTERRUPT is not
+       protected by a memory barrier, the cpu may delay making the
+       interrupt flag setting visible to the event loop thread until
+       the wakeUp is processed and the event loop is blocking again
+       (because interrupt was not visible at the time).  Due to the
+       complexity of the code involved, the race may be tiny, and the
+       interrupt is not guaranteed to be immediate anyway, but there
+       is no principled reason to believe the code works as written.
+       The proper way would be to add a lock around the interrupt
+       flag.  */
+    bool interrupt;
+
+    int doSelect(QEventLoop::ProcessEventsFlags flags, ticks_t timeout);
+    int activateTimers();
 };
 
 QEventDispatcherWin32Private::QEventDispatcherWin32Private()
-    : threadId(GetCurrentThreadId()), interrupt(false), internalHwnd(0), getMessageHook(0),
-      serialNumber(0), lastSerialNumber(0),
-#ifndef Q_OS_WINCE
-      lastMessageTime(0),
-#endif
-      wakeUps(0)
+    : interrupt(false), internalHwnd(0)
 {
-    resolveTimerAPI();
+    /* Automatic reset, initial state FALSE.  */
+    wakeUp = CreateEvent (NULL, FALSE, FALSE, NULL);
+    if (wakeUp == NULL) {
+        qWarning ("failed to create sendPostedEvents event: %d", (int) GetLastError ());
+    }
 }
 
 QEventDispatcherWin32Private::~QEventDispatcherWin32Private()
 {
     if (internalHwnd)
         DestroyWindow(internalHwnd);
-    QString className = QLatin1String("QEventDispatcherWin32_Internal_Widget") + QString::number(quintptr(qt_internal_proc));
+    QString className = QLatin1String("QEventDispatcherWin32_Internal_Widget")
+      + QString::number(quintptr(qt_internal_proc));
     UnregisterClass((wchar_t*)className.utf16(), qWinAppInst());
+    CloseHandle (wakeUp);
+
+    qDeleteAll(timerList);
+
+    while (!sockets.isEmpty()) {
+        QSockNot *sn = sockets.takeFirst();
+	WSACloseEvent (sn->event);
+	delete sn;
+    }
 }
 
-void QEventDispatcherWin32Private::activateEventNotifier(QWinEventNotifier * wen)
+int QEventDispatcherWin32Private::activateTimers()
 {
-    QEvent event(QEvent::WinEventAct);
-    QCoreApplication::sendEvent(wen, &event);
+#ifndef QT_NO_DEBUG
+    Q_Q(QEventDispatcherWin32);
+    Q_ASSERT(q->thread() == QThread::currentThread());
+#endif
+    return timerList.activateTimers();
 }
 
 // ### Qt 5: remove
@@ -424,16 +198,6 @@ Q_CORE_EXPORT bool winGetMessage(MSG* msg, HWND hWnd, UINT wMsgFilterMin,
     return GetMessage(msg, hWnd, wMsgFilterMin, wMsgFilterMax);
 }
 
-// This function is called by a workerthread
-void WINAPI QT_WIN_CALLBACK qt_fast_timer_proc(uint timerId, uint /*reserved*/, DWORD_PTR user, DWORD_PTR /*reserved*/, DWORD_PTR /*reserved*/)
-{
-    if (!timerId) // sanity check
-        return;
-    WinTimerInfo *t = (WinTimerInfo*)user;
-    Q_ASSERT(t);
-    QCoreApplication::postEvent(t->dispatcher, new QTimerEvent(t->timerId));
-}
-
 LRESULT QT_WIN_CALLBACK qt_internal_proc(HWND hwnd, UINT message, WPARAM wp, LPARAM lp)
 {
     if (message == WM_NCCREATE)
@@ -447,109 +211,20 @@ LRESULT QT_WIN_CALLBACK qt_internal_proc(HWND hwnd, UINT message, WPARAM wp, LPA
     QCoreApplication *app = QCoreApplication::instance();
     long result;
     if (!app) {
-        if (message == WM_TIMER)
-            KillTimer(hwnd, wp);
         return 0;
     } else if (app->filterEvent(&msg, &result)) {
         return result;
     }
 
-#ifdef GWLP_USERDATA
-    QEventDispatcherWin32 *q = (QEventDispatcherWin32 *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
-#else
-    QEventDispatcherWin32 *q = (QEventDispatcherWin32 *) GetWindowLong(hwnd, GWL_USERDATA);
-#endif
-    QEventDispatcherWin32Private *d = 0;
-    if (q != 0)
-        d = q->d_func();
-
-    if (message == WM_QT_SOCKETNOTIFIER) {
-        // socket notifier message
-        int type = -1;
-        switch (WSAGETSELECTEVENT(lp)) {
-        case FD_READ:
-        case FD_CLOSE:
-        case FD_ACCEPT:
-            type = 0;
-            break;
-        case FD_WRITE:
-        case FD_CONNECT:
-            type = 1;
-            break;
-        case FD_OOB:
-            type = 2;
-            break;
-        }
-        if (type >= 0) {
-            Q_ASSERT(d != 0);
-            QSNDict *sn_vec[3] = { &d->sn_read, &d->sn_write, &d->sn_except };
-            QSNDict *dict = sn_vec[type];
-
-            QSockNot *sn = dict ? dict->value(wp) : 0;
-            if (sn) {
-                QEvent event(QEvent::SockAct);
-                QCoreApplication::sendEvent(sn->obj, &event);
-            }
-        }
-        return 0;
-    } else if (message == WM_TIMER) {    
-        Q_ASSERT(d != 0);
-        d->sendTimerEvent(wp);
-        return 0;
-    } else if (message == WM_QT_SENDPOSTEDEVENTS) {
-        int localSerialNumber = d->serialNumber;
-        if (localSerialNumber != d->lastSerialNumber) {
-            d->lastSerialNumber = localSerialNumber;
-#ifndef Q_OS_WINCE
-            d->lastMessageTime = GetMessageTime();
-#endif
-            QCoreApplicationPrivate::sendPostedEvents(0, 0, d->threadData);
-        }
-        return 0;
-    }
-
     return DefWindowProc(hwnd, message, wp, lp);
 }
 
-LRESULT QT_WIN_CALLBACK qt_GetMessageHook(int code, WPARAM wp, LPARAM lp)
-{
-    if (wp == PM_REMOVE) {
-        QEventDispatcherWin32 *q = qobject_cast<QEventDispatcherWin32 *>(QAbstractEventDispatcher::instance());
-        Q_ASSERT(q != 0);
-        if (q) {
-            QEventDispatcherWin32Private *d = q->d_func();
-            int localSerialNumber = d->serialNumber;
-            MSG unused;
-            if ((HIWORD(GetQueueStatus(QS_INPUT | QS_RAWINPUT)) == 0
-                 && PeekMessage(&unused, 0, WM_TIMER, WM_TIMER, PM_NOREMOVE) == 0)
-#ifndef Q_OS_WINCE
-                || GetMessageTime() - d->lastMessageTime >= 10
-#endif
-                ) {
-                // no more input or timer events in the message queue or more than 10ms has elapsed since
-                // we send posted events, we can allow posted events to be sent now
-                (void) d->wakeUps.fetchAndStoreRelease(0);
-                MSG *msg = (MSG *) lp;
-                if (localSerialNumber != d->lastSerialNumber
-                    // if this message IS the one that triggers sendPostedEvents(), no need to post it again
-                    && (msg->hwnd != d->internalHwnd
-                        || msg->message != WM_QT_SENDPOSTEDEVENTS)) {
-                    PostMessage(d->internalHwnd, WM_QT_SENDPOSTEDEVENTS, 0, 0);
-                }
-            }
-        }
-    }
-#ifdef Q_OS_WINCE
-    return 0;
-#else
-    return CallNextHookEx(0, code, wp, lp);
-#endif
-}
 
 static HWND qt_create_internal_window(const QEventDispatcherWin32 *eventDispatcher)
 {
     // make sure that multiple Qt's can coexist in the same process
-    QString className = QLatin1String("QEventDispatcherWin32_Internal_Widget") + QString::number(quintptr(qt_internal_proc));
+    QString className = QLatin1String("QEventDispatcherWin32_Internal_Widget")
+      + QString::number(quintptr(qt_internal_proc));
 
     WNDCLASS wc;
     wc.style = 0;
@@ -572,9 +247,8 @@ static HWND qt_create_internal_window(const QEventDispatcherWin32 *eventDispatch
                             0,                 // menu handle
                             qWinAppInst(),     // application
                             0);                // windows creation data.
-
     if (!wnd) {
-        qWarning("QEventDispatcher: Failed to create QEventDispatcherWin32 internal window: %d\n", (int)GetLastError());
+        qWarning("QEventDispatcherWin32: Failed to create internal window: %d\n", (int)GetLastError());
     }
 
 #ifdef GWLP_USERDATA
@@ -586,81 +260,428 @@ static HWND qt_create_internal_window(const QEventDispatcherWin32 *eventDispatch
     return wnd;
 }
 
-void QEventDispatcherWin32Private::registerTimer(WinTimerInfo *t)
-{
-    Q_ASSERT(internalHwnd);
 
+int QEventDispatcherWin32Private::doSelect(QEventLoop::ProcessEventsFlags flags, ticks_t timeout)
+{
     Q_Q(QEventDispatcherWin32);
 
-    int ok = 0;
-    if (t->interval > 20 || !t->interval || !qtimeSetEvent) {
-        ok = 1;
-        if (!t->interval)  // optimization for single-shot-zero-timer
-            QCoreApplication::postEvent(q, new QZeroTimerEvent(t->timerId));
-        else
-            ok = SetTimer(internalHwnd, t->timerId, (uint) t->interval, 0);
-    } else {
-        ok = t->fastTimerId = qtimeSetEvent(t->interval, 1, qt_fast_timer_proc, (DWORD_PTR)t,
-                                            TIME_CALLBACK_FUNCTION | TIME_PERIODIC | TIME_KILL_SYNCHRONOUS);
-        if (ok == 0) { // fall back to normal timer if no more multimedia timers available
-            ok = SetTimer(internalHwnd, t->timerId, (uint) t->interval, 0);
+    /* Before calling any handlers, we save the list of events we
+       watch out for.  This is because running handlers can interfer
+       with the state of any other object, and we need to prevent
+       live-locks as well as making sure that we make some
+       progress.
+
+       NOTE: The existing unix and windows code is not careful enough
+       about this, either.  And even in this implementation we have a
+       flaw: We can not separate waiting for read/write/oob events on
+       a single socket, but they have different handlers.  If these
+       handlers interfere with each other, we are in trouble, too.  */
+    sn_pending_list.clear();
+    wn_pending_list.clear();
+
+    /* At the same time as making the above-mentioned copy, prepare
+       the event list for WFMO.  */
+    int wakeUpIdx = 0;
+    int socketIdx = wakeUpIdx + 1;
+    int wineventIdx = socketIdx;
+    if (!(flags & QEventLoop::ExcludeSocketNotifiers))
+      wineventIdx += sockets.size();
+    int nr_events = wineventIdx + winEventNotifierList.size();
+
+    HANDLE *events = new HANDLE[nr_events];
+    events[0] = wakeUp;
+    if (!(flags & QEventLoop::ExcludeSocketNotifiers))
+      {
+	for (int i = 0; i < sockets.size(); ++i)
+	  {
+	    events[socketIdx + i] = sockets[i]->event;
+	    sn_pending_list.append(sockets[i]);
+	  }
+      }
+    for (int i = 0; i < winEventNotifierList.size(); ++i)
+      {
+	events[wineventIdx + i] = winEventNotifierList[i]->handle();
+	wn_pending_list.append(winEventNotifierList[i]);
+      }
+
+    if (nr_events > MAXIMUM_WAIT_OBJECTS - 1)
+      {
+	qWarning ("Can not handle 1/%d/%d events (max: %d) - ignoring some",
+		  sockets.size(), winEventNotifierList.size(), MAXIMUM_WAIT_OBJECTS - 1);
+	nr_events = MAXIMUM_WAIT_OBJECTS - 1;
+      }
+
+    /* Note: At this point, SendMessage() can come in and cause a
+       function call into arbitrary handler code!  So after this, the
+       state of sockets and winEventNotifierList can be quite
+       different from before (sockets can be unregistered, etc).  */
+    DWORD result;
+    result = MsgWaitForMultipleObjectsEx(nr_events, events, timeout,
+					 QS_ALLINPUT, MWMO_ALERTABLE | MWMO_INPUTAVAILABLE);
+    if (result == WAIT_TIMEOUT || result == -1 || interrupt) {
+         delete[] events;
+	 return 0;
+    }
+
+    /* Return value.  */
+    int nevents = 0;
+
+    /* To avoid a live lock in case many events are sent, we return
+       after some maximum time (miliseconds).  */
+#define MAXIMUM_MSG_TIME 100
+    ticks_t currentTime = timerList.updateCurrentTime();
+    while (1) {
+	MSG msg;
+	bool haveMessage = PeekMessage(&msg, 0, 0, 0, PM_REMOVE);
+	if (!haveMessage)
+	  break;
+	
+	if ((flags & QEventLoop::ExcludeUserInputEvents)
+	    && ((msg.message >= WM_KEYFIRST
+		 && msg.message <= WM_KEYLAST)
+		|| (msg.message >= WM_MOUSEFIRST
+		    && msg.message <= WM_MOUSELAST)
+		|| msg.message == WM_MOUSEWHEEL
+		|| msg.message == WM_MOUSEHWHEEL
+		|| msg.message == WM_TOUCH
+#ifndef QT_NO_GESTURES
+		|| msg.message == WM_GESTURE
+		|| msg.message == WM_GESTURENOTIFY
+#endif
+		|| msg.message == WM_CLOSE)) {
+	  // queue user input events for later processing
+	  queuedUserInputEvents.append(msg);
+	  goto next_msg;
+	}
+	if (msg.message == WM_QUIT) {
+	  if (QCoreApplication::instance())
+	    QCoreApplication::instance()->quit();
+	  return ++nevents;
+	}
+	if (!q->filterEvent(&msg)) {
+	  TranslateMessage(&msg);
+	  /* This invokes handler code that can affect the state of
+	     sockets etc.  */
+	  DispatchMessage(&msg);
+	  ++nevents;
+	}
+      next_msg:
+	if (interrupt) {
+            delete[] events;       
+	    return nevents;
+	}
+	/* Avoid live lock by processing events for a maximum of
+	   MAXIMUM_MSG_TIME miliseconds once we get woken up.  */
+	if (timerList.updateCurrentTime() - currentTime > MAXIMUM_MSG_TIME)
+	  break;
+    }
+    
+    /* Now process the sockets and winEvents.  Note that we work on
+       the list of pending items to prevent a live lock.  The
+       unregister functions make sure to remove objects from there,
+       too, should they become unregistered by handlers in the
+       meantime.
+
+       We do not pay attention to system messages anymore: They had
+       their chance, and they have to wait for the next invocation.
+
+       We do not need to do anything about the wakeUp event: That is
+       resetted automatically, and has already served its purpose by
+       waking us up.
+
+       We give every socket and winevent only one chance here, to
+       prevent live locks by high bandwidth users.  */
+    while (!sn_pending_list.isEmpty())
+      {
+	QSockNot *sn = sn_pending_list[0];
+	result = WaitForSingleObject (sn->event, 0);
+	if (result != WAIT_OBJECT_0)
+	  {
+	    sn_pending_list.takeFirst();
+	    continue;
+	  }
+
+	/* This resets the event atomically.  So this is the point of
+	   no return: After this, we must process the event, no matter
+	   what, or it is lost (and we get synchronization problems).
+	   NOTE: Because we can only get a combination of
+	   READ/WRITE/OOB and not each one individually, we must
+	   process all three handlers (should they be registered and
+	   activated), which may cause problems if the handlers
+	   interfere with each other.  But don't fear: The Unix event
+	   loop doesn't cope with any socket handlers interfering with
+	   each other, nevermind handlers for the same socket (as is
+	   the case here).  */
+	WSANETWORKEVENTS ne;
+	int res = WSAEnumNetworkEvents (sn->sockfd, sn->event, &ne);
+	if (res != 0) {
+	    qWarning ("could not enumerate network events: %d", WSAGetLastError());
+	    sn_pending_list.takeFirst();
+	    continue;
+	} 
+
+	QEvent event(QEvent::SockAct);
+	if (sn->obj[0] && ne.lNetworkEvents & (FD_READ | FD_CLOSE | FD_ACCEPT)) {
+	    QCoreApplication::sendEvent(sn->obj[0], &event);
+	    ++nevents;
+	}
+	/* As you can see, at this point we may send more events
+	   without reconfirming that the state of the socket didn't
+	   change.  This is your clue that there is a potential
+	   interference problem!  But at the very least, make sure the
+	   socket was not unregistered in the meantime.  */
+	if (sn_pending_list.isEmpty() || sn_pending_list[0] != sn)
+	  {
+	    /* We don't remove the first here, because we know it's not sn.  */
+	    continue;
+	  }
+	if (sn->obj[1] && ne.lNetworkEvents & (FD_WRITE | FD_CONNECT)) {
+	    QCoreApplication::sendEvent(sn->obj[1], &event);
+	    ++nevents;
+	}
+	/* Again, same comment.  */
+	if (sn_pending_list.isEmpty() || sn_pending_list[0] != sn)
+	  {
+	    /* We don't remove the first here, because we know it's not sn.  */
+	    continue;
+	  }
+	if (sn->obj[2] && ne.lNetworkEvents & (FD_OOB)) {
+	    QCoreApplication::sendEvent(sn->obj[2], &event);
+	    ++nevents;
+	}
+	/* One last check, see comment.  But now we want to remove the
+	   object if it still exists, because we are done and need to
+	   make progress.  */
+	if (!sn_pending_list.isEmpty() && sn_pending_list[0] == sn)
+	  sn_pending_list.takeFirst();
+    }
+
+    while (!wn_pending_list.isEmpty()) {
+	QWinEventNotifier *wn = wn_pending_list.takeFirst();
+	result = WaitForSingleObject (wn->handle(), 0);
+	if (result != WAIT_OBJECT_0)
+	  continue;
+
+	/* Resetting this event is the responsibility of the caller.  */
+	QEvent event(QEvent::WinEventAct);
+	QCoreApplication::sendEvent(wn, &event);
+	++nevents;
+    }
+
+    delete[] events;
+    return nevents;
+}
+
+/*
+ * Internal functions for manipulating timer data structures.  The
+ * timerBitVec array is used for keeping track of timer identifiers.
+ */
+QTimerInfoList::QTimerInfoList()
+{
+    firstTimerInfo = 0;
+}
+
+ticks_t QTimerInfoList::updateCurrentTime()
+{
+  currentTime = GetTickCount();
+  return currentTime;
+}
+
+/*
+  insert timer info into list
+*/
+void QTimerInfoList::timerInsert(QTimerInfo *ti)
+{
+    int index = size();
+    while (index--) {
+        register const QTimerInfo * const t = at(index);
+        if (!((ticks_signed_t)(t->timeout - ti->timeout) > 0))
+            break;
+    }
+    insert(index+1, ti);
+}
+
+/*
+  Returns the time to wait for the next timer, or null if no timers
+  are waiting.
+*/
+bool QTimerInfoList::timerWait(ticks_t &tm)
+{
+    ticks_t currentTime = updateCurrentTime();
+
+    // Find first waiting timer not already active
+    QTimerInfo *t = 0;
+    for (QTimerInfoList::const_iterator it = constBegin(); it != constEnd(); ++it) {
+        if (!(*it)->activateRef) {
+            t = *it;
+            break;
         }
     }
 
-    if (ok == 0)
-        qErrnoWarning("QEventDispatcherWin32::registerTimer: Failed to create a timer");
+    if (!t)
+      return false;
+
+    if ((ticks_signed_t)(t->timeout - currentTime) > 0) {
+        // time to wait
+        tm = t->timeout - currentTime;
+    } else {
+        // no time to wait
+        tm = 0;
+    }
+
+    return true;
 }
 
-void QEventDispatcherWin32Private::unregisterTimer(WinTimerInfo *t, bool closingDown)
+void QTimerInfoList::registerTimer(int timerId, int interval, QObject *object)
 {
-    // mark timer as unused
-    if (!QObjectPrivate::get(t->obj)->inThreadChangeEvent && !closingDown)
-        QAbstractEventDispatcherPrivate::releaseTimerId(t->timerId);
-
-    if (t->interval == 0) {
-        QCoreApplicationPrivate::removePostedTimerEvent(t->dispatcher, t->timerId);
-    } else if (t->fastTimerId != 0) {
-        qtimeKillEvent(t->fastTimerId);
-        QCoreApplicationPrivate::removePostedTimerEvent(t->dispatcher, t->timerId);
-    } else if (internalHwnd) {
-        KillTimer(internalHwnd, t->timerId);
+    QTimerInfo *t = new QTimerInfo;
+    t->id = timerId;
+    t->interval = interval;
+    /* It's okay if this overflows: We only ever compare differences
+       as signed integers to 0.  The longest supported interval is half
+       of the maximum ticks_t, on Windows CE with 32 bit this is
+       approximately 25 days.  */
+    t->timeout = updateCurrentTime() + t->interval;
+    t->obj = object;
+    t->activateRef = 0;
+
+    timerInsert(t);
+}
+
+bool QTimerInfoList::unregisterTimer(int timerId)
+{
+    // set timer inactive
+    for (int i = 0; i < count(); ++i) {
+        register QTimerInfo *t = at(i);
+        if (t->id == timerId) {
+            // found it
+            removeAt(i);
+            if (t == firstTimerInfo)
+                firstTimerInfo = 0;
+            if (t->activateRef)
+                *(t->activateRef) = 0;
+
+            // release the timer id
+            if (!QObjectPrivate::get(t->obj)->inThreadChangeEvent)
+                QAbstractEventDispatcherPrivate::releaseTimerId(timerId);
+
+            delete t;
+            return true;
+        }
     }
-    delete t;
+    // id not found
+    return false;
 }
 
-void QEventDispatcherWin32Private::sendTimerEvent(int timerId)
+bool QTimerInfoList::unregisterTimers(QObject *object)
 {
-    WinTimerInfo *t = timerDict.value(timerId);
-    if (t && !t->inTimerEvent) {
-        // send event, but don't allow it to recurse
-        t->inTimerEvent = true;
-
-        QTimerEvent e(t->timerId);
-        QCoreApplication::sendEvent(t->obj, &e);
-
-        // timer could have been removed
-        t = timerDict.value(timerId);
-        if (t) {
-            t->inTimerEvent = false;
+    if (isEmpty())
+        return false;
+    for (int i = 0; i < count(); ++i) {
+        register QTimerInfo *t = at(i);
+        if (t->obj == object) {
+            // object found
+            removeAt(i);
+            if (t == firstTimerInfo)
+                firstTimerInfo = 0;
+            if (t->activateRef)
+                *(t->activateRef) = 0;
+
+            // release the timer id
+            if (!QObjectPrivate::get(t->obj)->inThreadChangeEvent)
+                QAbstractEventDispatcherPrivate::releaseTimerId(t->id);
+
+            delete t;
+            // move back one so that we don't skip the new current item
+            --i;
         }
     }
+    return true;
+}
+
+QList<QPair<int, int> > QTimerInfoList::registeredTimers(QObject *object) const
+{
+    QList<QPair<int, int> > list;
+    for (int i = 0; i < count(); ++i) {
+        register const QTimerInfo * const t = at(i);
+        if (t->obj == object)
+            list << QPair<int, int>(t->id, t->interval);
+    }
+    return list;
 }
 
-void QEventDispatcherWin32Private::doWsaAsyncSelect(int socket)
+/*
+    Activate pending timers, returning how many where activated.
+*/
+int QTimerInfoList::activateTimers()
 {
-    Q_ASSERT(internalHwnd);
-    int sn_event = 0;
-    if (sn_read.contains(socket))
-        sn_event |= FD_READ | FD_CLOSE | FD_ACCEPT;
-    if (sn_write.contains(socket))
-        sn_event |= FD_WRITE | FD_CONNECT;
-    if (sn_except.contains(socket))
-        sn_event |= FD_OOB;
-    // BoundsChecker may emit a warning for WSAAsyncSelect when sn_event == 0
-    // This is a BoundsChecker bug and not a Qt bug
-    WSAAsyncSelect(socket, internalHwnd, sn_event ? WM_QT_SOCKETNOTIFIER : 0, sn_event);
+    if (isEmpty())
+        return 0; // nothing to do
+
+    int n_act = 0, maxCount = 0;
+    firstTimerInfo = 0;
+
+    ticks_t currentTime = updateCurrentTime();
+
+    // Find out how many timer have expired
+    for (QTimerInfoList::const_iterator it = constBegin(); it != constEnd(); ++it) {
+      if ((ticks_signed_t)((*it)->timeout - currentTime) > 0)
+            break;
+        maxCount++;
+    }
+
+    //fire the timers.
+    while (maxCount--) {
+        if (isEmpty())
+            break;
+
+        QTimerInfo *currentTimerInfo = first();
+        if ((ticks_signed_t)(currentTimerInfo->timeout - currentTime) > 0)
+            break; // no timer has expired
+
+        if (!firstTimerInfo) {
+            firstTimerInfo = currentTimerInfo;
+        } else if (firstTimerInfo == currentTimerInfo) {
+            // avoid sending the same timer multiple times
+            break;
+        } else if (currentTimerInfo->interval <  firstTimerInfo->interval
+                   || currentTimerInfo->interval == firstTimerInfo->interval) {
+            firstTimerInfo = currentTimerInfo;
+        }
+
+        // remove from list
+        removeFirst();
+
+        // determine next timeout time
+        currentTimerInfo->timeout += currentTimerInfo->interval;
+        if ((ticks_signed_t)(currentTime - currentTimerInfo->timeout) > 0)
+            currentTimerInfo->timeout = currentTime + currentTimerInfo->interval;
+
+        // reinsert timer
+        timerInsert(currentTimerInfo);
+        if (currentTimerInfo->interval > 0)
+            n_act++;
+
+        if (!currentTimerInfo->activateRef) {
+            // send event, but don't allow it to recurse
+            currentTimerInfo->activateRef = &currentTimerInfo;
+
+            QTimerEvent e(currentTimerInfo->id);
+            QCoreApplication::sendEvent(currentTimerInfo->obj, &e);
+
+            if (currentTimerInfo)
+                currentTimerInfo->activateRef = 0;
+        }
+    }
+
+    firstTimerInfo = 0;
+    return n_act;
 }
 
+/*****************************************************************************
+ QEventDispatcher implementations for WINDOWS
+ *****************************************************************************/
+
 void QEventDispatcherWin32::createInternalHwnd()
 {
     Q_D(QEventDispatcherWin32);
@@ -669,28 +690,6 @@ void QEventDispatcherWin32::createInternalHwnd()
     if (d->internalHwnd)
         return;
     d->internalHwnd = qt_create_internal_window(this);
-
-#ifndef Q_OS_WINCE
-    // setup GetMessage hook needed to drive our posted events
-    d->getMessageHook = SetWindowsHookEx(WH_GETMESSAGE, (HOOKPROC) qt_GetMessageHook, NULL, GetCurrentThreadId());
-    if (!d->getMessageHook) {
-        qFatal("Qt: INTERNALL ERROR: failed to install GetMessage hook");
-    }
-#endif
-
-    // register all socket notifiers
-    QList<int> sockets = (d->sn_read.keys().toSet()
-                          + d->sn_write.keys().toSet()
-                          + d->sn_except.keys().toSet()).toList();
-    for (int i = 0; i < sockets.count(); ++i)
-        d->doWsaAsyncSelect(sockets.at(i));
-
-    // start all normal timers
-    for (int i = 0; i < d->timerVec.count(); ++i)
-        d->registerTimer(d->timerVec.at(i));
-
-    // trigger a call to sendPostedEvents()
-    wakeUp();
 }
 
 QEventDispatcherWin32::QEventDispatcherWin32(QObject *parent)
@@ -700,155 +699,70 @@ QEventDispatcherWin32::QEventDispatcherWin32(QObject *parent)
 
 QEventDispatcherWin32::~QEventDispatcherWin32()
 {
+    Q_D(QEventDispatcherWin32);
+    d->threadData->eventDispatcher = 0;
 }
 
 bool QEventDispatcherWin32::processEvents(QEventLoop::ProcessEventsFlags flags)
 {
     Q_D(QEventDispatcherWin32);
-
-    if (!d->internalHwnd)
-        createInternalHwnd();
-
     d->interrupt = false;
-    emit awake();
-
-    bool canWait;
-    bool retVal = false;
-    bool seenWM_QT_SENDPOSTEDEVENTS = false;
-    bool needWM_QT_SENDPOSTEDEVENTS = false;
-    do {
-        DWORD waitRet = 0;
-        HANDLE pHandles[MAXIMUM_WAIT_OBJECTS - 1];
-        QVarLengthArray<MSG> processedTimers;
-        while (!d->interrupt) {
-            DWORD nCount = d->winEventNotifierList.count();
-            Q_ASSERT(nCount < MAXIMUM_WAIT_OBJECTS - 1);
-
-            MSG msg;
-            bool haveMessage;
-
-            if (!(flags & QEventLoop::ExcludeUserInputEvents) && !d->queuedUserInputEvents.isEmpty()) {
-                // process queued user input events
-                haveMessage = true;
-                msg = d->queuedUserInputEvents.takeFirst();
-            } else if(!(flags & QEventLoop::ExcludeSocketNotifiers) && !d->queuedSocketEvents.isEmpty()) {
-                // process queued socket events
-                haveMessage = true;
-                msg = d->queuedSocketEvents.takeFirst();
-            } else {
-                haveMessage = PeekMessage(&msg, 0, 0, 0, PM_REMOVE);
-                if (haveMessage && (flags & QEventLoop::ExcludeUserInputEvents)
-                    && ((msg.message >= WM_KEYFIRST
-                         && msg.message <= WM_KEYLAST)
-                        || (msg.message >= WM_MOUSEFIRST
-                            && msg.message <= WM_MOUSELAST)
-                        || msg.message == WM_MOUSEWHEEL
-                        || msg.message == WM_MOUSEHWHEEL
-                        || msg.message == WM_TOUCH
-#ifndef QT_NO_GESTURES
-                        || msg.message == WM_GESTURE
-                        || msg.message == WM_GESTURENOTIFY
-#endif
-                        || msg.message == WM_CLOSE)) {
-                    // queue user input events for later processing
-                    haveMessage = false;
-                    d->queuedUserInputEvents.append(msg);
-                }
-                if (haveMessage && (flags & QEventLoop::ExcludeSocketNotifiers)
-                    && (msg.message == WM_QT_SOCKETNOTIFIER && msg.hwnd == d->internalHwnd)) {
-                    // queue socket events for later processing
-                    haveMessage = false;
-                    d->queuedSocketEvents.append(msg);
-                }
-            }
-            if (!haveMessage) {
-                // no message - check for signalled objects
-                for (int i=0; i<(int)nCount; i++)
-                    pHandles[i] = d->winEventNotifierList.at(i)->handle();
-                waitRet = MsgWaitForMultipleObjectsEx(nCount, pHandles, 0, QS_ALLINPUT, MWMO_ALERTABLE);
-                if ((haveMessage = (waitRet == WAIT_OBJECT_0 + nCount))) {
-                    // a new message has arrived, process it
-                    continue;
-                }
-            }
-            if (haveMessage) {
-#ifdef Q_OS_WINCE
-                // WinCE doesn't support hooks at all, so we have to call this by hand :(
-                (void) qt_GetMessageHook(0, PM_REMOVE, (LPARAM) &msg);
-#endif
-
-                if (d->internalHwnd == msg.hwnd && msg.message == WM_QT_SENDPOSTEDEVENTS) {
-                    if (seenWM_QT_SENDPOSTEDEVENTS) {
-                        // when calling processEvents() "manually", we only want to send posted
-                        // events once
-                        needWM_QT_SENDPOSTEDEVENTS = true;
-                        continue;
-                    }
-                    seenWM_QT_SENDPOSTEDEVENTS = true;
-                } else if (msg.message == WM_TIMER) {
-                    // avoid live-lock by keeping track of the timers we've already sent
-                    bool found = false;
-                    for (int i = 0; !found && i < processedTimers.count(); ++i) {
-                        const MSG processed = processedTimers.constData()[i];
-                        found = (processed.wParam == msg.wParam && processed.hwnd == msg.hwnd && processed.lParam == msg.lParam);
-                    }
-                    if (found)
-                        continue;
-                    processedTimers.append(msg);
-                } else if (msg.message == WM_QUIT) {
-                    if (QCoreApplication::instance())
-                        QCoreApplication::instance()->quit();
-                    return false;
-                }
-
-                if (!filterEvent(&msg)) {
-                    TranslateMessage(&msg);
-                    DispatchMessage(&msg);
-                }
-            } else if (waitRet >= WAIT_OBJECT_0 && waitRet < WAIT_OBJECT_0 + nCount) {
-                d->activateEventNotifier(d->winEventNotifierList.at(waitRet - WAIT_OBJECT_0));
-            } else {
-                // nothing todo so break
-                break;
-            }
-            retVal = true;
-        }
 
-        // still nothing - wait for message or signalled objects
-        canWait = (!retVal
-                   && !d->interrupt
-                   && (flags & QEventLoop::WaitForMoreEvents));
-        if (canWait) {
-            DWORD nCount = d->winEventNotifierList.count();
-            Q_ASSERT(nCount < MAXIMUM_WAIT_OBJECTS - 1);
-            for (int i=0; i<(int)nCount; i++)
-                pHandles[i] = d->winEventNotifierList.at(i)->handle();
-
-            emit aboutToBlock();
-            waitRet = MsgWaitForMultipleObjectsEx(nCount, pHandles, INFINITE, QS_ALLINPUT, MWMO_ALERTABLE | MWMO_INPUTAVAILABLE);
-            emit awake();
-            if (waitRet >= WAIT_OBJECT_0 && waitRet < WAIT_OBJECT_0 + nCount) {
-                d->activateEventNotifier(d->winEventNotifierList.at(waitRet - WAIT_OBJECT_0));
-                retVal = true;
-            }
-        }
-    } while (canWait);
-
-    if (!seenWM_QT_SENDPOSTEDEVENTS && (flags & QEventLoop::EventLoopExec) == 0) {
-        // when called "manually", always send posted events
-        QCoreApplicationPrivate::sendPostedEvents(0, 0, d->threadData);
-    }
-
-    if (needWM_QT_SENDPOSTEDEVENTS)
-        PostMessage(d->internalHwnd, WM_QT_SENDPOSTEDEVENTS, 0, 0);
-
-    return retVal;
+    // we are awake, broadcast it
+    emit awake();
+    QCoreApplicationPrivate::sendPostedEvents(0, 0, d->threadData);
+    if (d->interrupt)
+        goto out;
+
+    int nevents = 0;
+
+    if (!(flags & QEventLoop::ExcludeUserInputEvents)) {
+	// process queued user input events
+	while (!d->queuedUserInputEvents.isEmpty()) {
+            MSG msg = d->queuedUserInputEvents.takeFirst();
+	    if (!filterEvent(&msg)) {
+	        ++nevents;
+	        TranslateMessage(&msg);
+	        DispatchMessage(&msg);
+	    }
+	    if (d->interrupt)
+	        goto out;
+	}
+    }
+
+    const bool canWait = (d->threadData->canWait
+                          && (flags & QEventLoop::WaitForMoreEvents));
+    if (canWait)
+        emit aboutToBlock();
+
+    // Determine the maximum time we can wait for an event.
+    ticks_t tm = INFINITE;
+    if (!canWait)
+        tm = 0;
+    else if (!(flags & QEventLoop::X11ExcludeTimers))
+        d->timerList.timerWait(tm);
+    
+    nevents += d->doSelect(flags, tm);
+    if (d->interrupt)
+        goto out;
+
+    // activate timers
+    if (! (flags & QEventLoop::X11ExcludeTimers)) {
+        nevents += d->activateTimers();
+    }
+ out:
+    // return true if we handled events, false otherwise
+    return (nevents > 0);
 }
 
+
 bool QEventDispatcherWin32::hasPendingEvents()
 {
-    MSG msg;
-    return qGlobalPostedEventsCount() || PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);
+    /* NOTE: This used to call PeekMessage(&msg, NULL, 0, 0,
+       PM_NOREMOVE), but hasPendingEvents is best effort anyway (it
+       doesn't look at sockets, for example), so why be inconsistent
+       with Unix?  */
+    return qGlobalPostedEventsCount();
 }
 
 void QEventDispatcherWin32::registerSocketNotifier(QSocketNotifier *notifier)
@@ -856,70 +770,122 @@ void QEventDispatcherWin32::registerSocketNotifier(QSocketNotifier *notifier)
     Q_ASSERT(notifier);
     int sockfd = notifier->socket();
     int type = notifier->type();
+
 #ifndef QT_NO_DEBUG
     if (sockfd < 0) {
-        qWarning("QSocketNotifier: Internal error");
+        qWarning("QEventDispatcherWin32: Internal error");
         return;
-    } else if (notifier->thread() != thread() || thread() != QThread::currentThread()) {
-        qWarning("QSocketNotifier: socket notifiers cannot be enabled from another thread");
+    } else if (notifier->thread() != thread()
+               || thread() != QThread::currentThread()) {
+        qWarning("QEventDispatcherWin32: socket notifiers cannot be enabled from another thread");
         return;
     }
 #endif
 
     Q_D(QEventDispatcherWin32);
-    QSNDict *sn_vec[3] = { &d->sn_read, &d->sn_write, &d->sn_except };
-    QSNDict *dict = sn_vec[type];
-
-    if (QCoreApplication::closingDown()) // ### d->exitloop?
-        return; // after sn_cleanup, don't reinitialize.
-
-    if (dict->contains(sockfd)) {
-        const char *t[] = { "Read", "Write", "Exception" };
-    /* Variable "socket" below is a function pointer. */
-        qWarning("QSocketNotifier: Multiple socket notifiers for "
-                 "same socket %d and type %s", sockfd, t[type]);
+    QSockNot *sn = 0;
+    int i;
+    for (i = 0; i < d->sockets.size(); ++i)
+      {
+	if (d->sockets[i]->sockfd == sockfd)
+	  break;
+      }
+    if (i < d->sockets.size())
+      {
+	if (d->sockets[i]->obj[type])
+	  return;
+
+	/* Need to add the flag to watch for.  */
+	sn = d->sockets[i];
+      }
+    else
+      {
+	sn = new QSockNot;
+	sn->sockfd = sockfd;
+	sn->obj[0] = 0;
+	sn->obj[1] = 0;
+	sn->obj[2] = 0;
+	sn->event = WSACreateEvent();
+	d->sockets.append(sn);
+      }
+    sn->obj[type] = notifier;
+
+    int flags = 0;
+    if (sn->obj[0])
+      flags |= FD_READ | FD_CLOSE | FD_ACCEPT;
+    if (sn->obj[1])
+      flags |= FD_WRITE | FD_CONNECT;
+    if (sn->obj[2])
+      flags |= FD_OOB;
+
+    int res = WSAEventSelect(sockfd, sn->event, flags);
+    if (res != 0) {
+        qWarning ("Failed to register socket: %d", WSAGetLastError());
     }
-
-    QSockNot *sn = new QSockNot;
-    sn->obj = notifier;
-    sn->fd  = sockfd;
-    dict->insert(sn->fd, sn);
-
-    if (d->internalHwnd)
-        d->doWsaAsyncSelect(sockfd);
 }
 
 void QEventDispatcherWin32::unregisterSocketNotifier(QSocketNotifier *notifier)
 {
     Q_ASSERT(notifier);
     int sockfd = notifier->socket();
-    int type = notifier->type();
 #ifndef QT_NO_DEBUG
     if (sockfd < 0) {
-        qWarning("QSocketNotifier: Internal error");
+        qWarning("QEventDispatcherWin32: Internal error");
         return;
-    } else if (notifier->thread() != thread() || thread() != QThread::currentThread()) {
-        qWarning("QSocketNotifier: socket notifiers cannot be disabled from another thread");
+    } else if (notifier->thread() != thread()
+               || thread() != QThread::currentThread()) {
+        qWarning("QEventDispatcherWin32: socket notifiers cannot be disabled from another thread");
         return;
     }
 #endif
 
     Q_D(QEventDispatcherWin32);
-    QSNDict *sn_vec[3] = { &d->sn_read, &d->sn_write, &d->sn_except };
-    QSNDict *dict = sn_vec[type];
-    QSockNot *sn = dict->value(sockfd);
-    if (!sn)
-        return;
-
-    dict->remove(sockfd);
-    delete sn;
-
-    if (d->internalHwnd)
-        d->doWsaAsyncSelect(sockfd);
+    QSockNot *sn = 0;
+    int i;
+    for (i = 0; i < d->sockets.size(); ++i)
+      {
+	if (d->sockets[i]->sockfd == sockfd)
+	  break;
+      }
+    if (i == d->sockets.size())
+      return;
+    sn = d->sockets[i];
+
+    bool found = false;
+    for (int j = 0; j < 3; ++j)
+      if (sn->obj[j] == notifier)
+	{
+	  sn->obj[j] = 0;
+	  found = 1;
+	}
+    if (!found)
+      return;
+
+    int flags = 0;
+    if (sn->obj[0])
+      flags |= FD_READ | FD_CLOSE | FD_ACCEPT;
+    if (sn->obj[1])
+      flags |= FD_WRITE | FD_CONNECT;
+    if (sn->obj[2])
+      flags |= FD_OOB;
+    
+    if (flags == 0)
+      {
+	WSACloseEvent (sn->event);
+	d->sockets.removeAt(i);  // remove notifier found above
+	d->sn_pending_list.removeAll(sn);
+	delete sn;
+	return;
+      }
+    int res = WSAEventSelect(sockfd, sn->event, flags);
+    if (res != 0) {
+        qWarning ("Failed to unregister socket: %d", WSAGetLastError());
+    }
 }
 
 void QEventDispatcherWin32::registerTimer(int timerId, int interval, QObject *object)
 {
+#ifndef QT_NO_DEBUG
     if (timerId < 1 || interval < 0 || !object) {
         qWarning("QEventDispatcherWin32::registerTimer: invalid arguments");
         return;
@@ -927,76 +893,44 @@ void QEventDispatcherWin32::registerTimer(int timerId, int interval, QObject *ob
         qWarning("QObject::startTimer: timers cannot be started from another thread");
         return;
     }
+#endif
 
     Q_D(QEventDispatcherWin32);
-
-    register WinTimerInfo *t = new WinTimerInfo;
-    t->dispatcher = this;
-    t->timerId  = timerId;
-    t->interval = interval;
-    t->obj  = object;
-    t->inTimerEvent = false;
-    t->fastTimerId = 0;
-
-    if (d->internalHwnd)
-        d->registerTimer(t);
-
-    d->timerVec.append(t);                      // store in timer vector
-    d->timerDict.insert(t->timerId, t);          // store timers in dict
+    d->timerList.registerTimer(timerId, interval, object);
 }
 
 bool QEventDispatcherWin32::unregisterTimer(int timerId)
 {
+#ifndef QT_NO_DEBUG
     if (timerId < 1) {
         qWarning("QEventDispatcherWin32::unregisterTimer: invalid argument");
         return false;
     }
-    QThread *currentThread = QThread::currentThread();
-    if (thread() != currentThread) {
+    if (thread() != QThread::currentThread()) {
         qWarning("QObject::killTimer: timers cannot be stopped from another thread");
         return false;
     }
+#endif
 
     Q_D(QEventDispatcherWin32);
-    if (d->timerVec.isEmpty() || timerId <= 0)
-        return false;
-
-    WinTimerInfo *t = d->timerDict.value(timerId);
-    if (!t)
-        return false;
-
-    d->timerDict.remove(t->timerId);
-    d->timerVec.removeAll(t);
-    d->unregisterTimer(t);
-    return true;
+    return d->timerList.unregisterTimer(timerId);
 }
 
 bool QEventDispatcherWin32::unregisterTimers(QObject *object)
 {
+#ifndef QT_NO_DEBUG
     if (!object) {
         qWarning("QEventDispatcherWin32::unregisterTimers: invalid argument");
         return false;
     }
-    QThread *currentThread = QThread::currentThread();
-    if (object->thread() != thread() || thread() != currentThread) {
+    if (object->thread() != thread() || thread() != QThread::currentThread()) {
         qWarning("QObject::killTimers: timers cannot be stopped from another thread");
         return false;
     }
+#endif
 
     Q_D(QEventDispatcherWin32);
-    if (d->timerVec.isEmpty())
-        return false;
-    register WinTimerInfo *t;
-    for (int i=0; i<d->timerVec.size(); i++) {
-        t = d->timerVec.at(i);
-        if (t && t->obj == object) {                // object found
-            d->timerDict.remove(t->timerId);
-            d->timerVec.removeAt(i);
-            d->unregisterTimer(t);
-            --i;
-        }
-    }
-    return true;
+    return d->timerList.unregisterTimers(object);
 }
 
 QList<QEventDispatcherWin32::TimerInfo>
@@ -1008,17 +942,12 @@ QEventDispatcherWin32::registeredTimers(QObject *object) const
     }
 
     Q_D(const QEventDispatcherWin32);
-    QList<TimerInfo> list;
-    for (int i = 0; i < d->timerVec.size(); ++i) {
-        const WinTimerInfo *t = d->timerVec.at(i);
-        if (t && t->obj == object)
-            list << TimerInfo(t->timerId, t->interval);
-    }
-    return list;
+    return d->timerList.registeredTimers(object);
 }
 
 bool QEventDispatcherWin32::registerEventNotifier(QWinEventNotifier *notifier)
 {
+#ifndef QT_NO_DEBUG
     if (!notifier) {
         qWarning("QWinEventNotifier: Internal error");
         return false;
@@ -1026,10 +955,15 @@ bool QEventDispatcherWin32::registerEventNotifier(QWinEventNotifier *notifier)
         qWarning("QWinEventNotifier: event notifiers cannot be enabled from another thread");
         return false;
     }
+#endif
 
     Q_D(QEventDispatcherWin32);
+    int i;
 
-    if (d->winEventNotifierList.contains(notifier))
+    for (i = 0; i < d->winEventNotifierList.size(); ++i)
+        if (d->winEventNotifierList[i] == notifier)
+	    break;
+    if (i != d->winEventNotifierList.size())
         return true;
 
     if (d->winEventNotifierList.count() >= MAXIMUM_WAIT_OBJECTS - 2) {
@@ -1042,6 +976,7 @@ bool QEventDispatcherWin32::registerEventNotifier(QWinEventNotifier *notifier)
 
 void QEventDispatcherWin32::unregisterEventNotifier(QWinEventNotifier *notifier)
 {
+#ifndef QT_NO_DEBUG
     if (!notifier) {
         qWarning("QWinEventNotifier: Internal error");
         return;
@@ -1049,36 +984,26 @@ void QEventDispatcherWin32::unregisterEventNotifier(QWinEventNotifier *notifier)
         qWarning("QWinEventNotifier: event notifiers cannot be disabled from another thread");
         return;
     }
+#endif
 
     Q_D(QEventDispatcherWin32);
 
-    int i = d->winEventNotifierList.indexOf(notifier);
-    if (i != -1)
-        d->winEventNotifierList.takeAt(i);
-}
+    int i;
+    for (i = 0; i < d->winEventNotifierList.size(); ++i)
+        if (d->winEventNotifierList[i] == notifier)
+	    break;
+    if (i == d->winEventNotifierList.size())
+        return;
 
-void QEventDispatcherWin32::activateEventNotifiers()
-{
-    Q_D(QEventDispatcherWin32);
-    //### this could break if events are removed/added in the activation
-    for (int i=0; i<d->winEventNotifierList.count(); i++) {
-#if !defined(Q_OS_WINCE)
-        if (WaitForSingleObjectEx(d->winEventNotifierList.at(i)->handle(), 0, TRUE) == WAIT_OBJECT_0)
-            d->activateEventNotifier(d->winEventNotifierList.at(i));
-#else
-        if (WaitForSingleObject(d->winEventNotifierList.at(i)->handle(), 0) == WAIT_OBJECT_0)
-            d->activateEventNotifier(d->winEventNotifierList.at(i));
-#endif
-    }
+    d->winEventNotifierList.removeAt(i);
+    d->wn_pending_list.removeAll(notifier);
 }
 
 void QEventDispatcherWin32::wakeUp()
 {
     Q_D(QEventDispatcherWin32);
-    d->serialNumber.ref();
-    if (d->internalHwnd && d->wakeUps.testAndSetAcquire(0, 1)) {
-        // post a WM_QT_SENDPOSTEDEVENTS to this thread if there isn't one already pending
-        PostMessage(d->internalHwnd, WM_QT_SENDPOSTEDEVENTS, 0, 0);
+    if (!SetEvent (d->wakeUp)) {
+      qWarning ("SetEvent failed: %d", (int) GetLastError());
     }
 }
 
@@ -1092,62 +1017,4 @@ void QEventDispatcherWin32::interrupt()
 void QEventDispatcherWin32::flush()
 { }
 
-void QEventDispatcherWin32::startingUp()
-{ }
-
-void QEventDispatcherWin32::closingDown()
-{
-    Q_D(QEventDispatcherWin32);
-
-    // clean up any socketnotifiers
-    while (!d->sn_read.isEmpty())
-        unregisterSocketNotifier((*(d->sn_read.begin()))->obj);
-    while (!d->sn_write.isEmpty())
-        unregisterSocketNotifier((*(d->sn_write.begin()))->obj);
-    while (!d->sn_except.isEmpty())
-        unregisterSocketNotifier((*(d->sn_except.begin()))->obj);
-
-    // clean up any timers
-    for (int i = 0; i < d->timerVec.count(); ++i)
-        d->unregisterTimer(d->timerVec.at(i), true);
-    d->timerVec.clear();
-    d->timerDict.clear();
-
-#ifndef Q_OS_WINCE
-    if (d->getMessageHook)
-        UnhookWindowsHookEx(d->getMessageHook);
-    d->getMessageHook = 0;
-#endif
-}
-
-bool QEventDispatcherWin32::event(QEvent *e)
-{
-    Q_D(QEventDispatcherWin32);
-    if (e->type() == QEvent::ZeroTimerEvent) {
-        QZeroTimerEvent *zte = static_cast<QZeroTimerEvent*>(e);
-        WinTimerInfo *t = d->timerDict.value(zte->timerId());
-        if (t) {
-            t->inTimerEvent = true;
-
-            QTimerEvent te(zte->timerId());
-            QCoreApplication::sendEvent(t->obj, &te);
-
-            t = d->timerDict.value(zte->timerId());
-            if (t) {
-                if (t->interval == 0 && t->inTimerEvent) {
-                    // post the next zero timer event as long as the timer was not restarted
-                    QCoreApplication::postEvent(this, new QZeroTimerEvent(zte->timerId()));
-                }
-
-                t->inTimerEvent = false;
-            }
-        }
-        return true;
-    } else if (e->type() == QEvent::Timer) {
-        QTimerEvent *te = static_cast<QTimerEvent*>(e);
-        d->sendTimerEvent(te->timerId());
-    }
-    return QAbstractEventDispatcher::event(e);
-}
-
 QT_END_NAMESPACE
diff --git a/src/corelib/kernel/qeventdispatcher_win_p.h b/src/corelib/kernel/qeventdispatcher_win_p.h
index b219841..5bc6576 100644
--- a/src/corelib/kernel/qeventdispatcher_win_p.h
+++ b/src/corelib/kernel/qeventdispatcher_win_p.h
@@ -54,10 +54,51 @@
 //
 
 #include "QtCore/qabstracteventdispatcher.h"
+#include "QtCore/qlist.h"
 #include "QtCore/qt_windows.h"
 
 QT_BEGIN_NAMESPACE
 
+/* This must be unsigned and have the same width as the monotonous
+   clock source.  */
+typedef DWORD ticks_t;
+/* To tell earlier from later, we need a signed integer type of the
+   same width as ticks_t.  */
+typedef INT32 ticks_signed_t;
+
+// internal timer info
+struct QTimerInfo {
+    int id;           // - timer identifier
+    ticks_t interval;   // - timer interval
+    ticks_t timeout;    // - when to sent event
+    QObject *obj;     // - object to receive event
+    QTimerInfo **activateRef; // - ref from activateTimers
+};
+
+class QTimerInfoList : public QList<QTimerInfo*>
+{
+    // state variables used by activateTimers()
+    QTimerInfo *firstTimerInfo;
+
+public:
+    QTimerInfoList();
+
+    ticks_t currentTime;
+    ticks_t updateCurrentTime();
+
+    bool timerWait(ticks_t &);
+    void timerInsert(QTimerInfo *);
+
+    void registerTimer(int timerId, int interval, QObject *object);
+    bool unregisterTimer(int timerId);
+    bool unregisterTimers(QObject *object);
+    QList<QPair<int, int> > registeredTimers(QObject *object) const;
+
+    int activateSocketNotifiers();
+    void activateEventNotifiers();
+    int activateTimers();
+};
+
 class QWinEventNotifier;
 class QEventDispatcherWin32Private;
 
@@ -89,22 +130,16 @@ public:
 
     bool registerEventNotifier(QWinEventNotifier *notifier);
     void unregisterEventNotifier(QWinEventNotifier *notifier);
-    void activateEventNotifiers();
 
     void wakeUp();
     void interrupt();
     void flush();
 
-    void startingUp();
-    void closingDown();
-
-    bool event(QEvent *e);
-
 private:
     friend LRESULT QT_WIN_CALLBACK qt_internal_proc(HWND hwnd, UINT message, WPARAM wp, LPARAM lp);
-    friend LRESULT QT_WIN_CALLBACK qt_GetMessageHook(int, WPARAM, LPARAM);
 };
 
+
 QT_END_NAMESPACE
 
 #endif // QEVENTDISPATCHER_WIN_P_H
-- 
1.5.6.5

